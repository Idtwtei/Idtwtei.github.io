<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>LOJ 2731 棋盘游戏</title>
      <link href="/LOJ2731/"/>
      <url>/LOJ2731/</url>
      
        <content type="html"><![CDATA[<blockquote><p>一张 $3 \times n$ 棋盘，每个格子上放置了 $0/1$ 个棋子，你可以选择一个上下或左右均有棋子的位置放置棋子，最后放满整个棋盘，求放置的方案数，对 $10^9 + 7$ 取模。</p><p>$1 \le n \le 2 \times 10^3$。</p></blockquote><p>考虑什么样的棋盘可以放满，四个角必须有棋子，第一行和第三行只能通过左右有棋子的方式放置，那么不能有两个连续的空位。易证这是充要的。先判断，不能放满输出 $0$。</p><p>第一行和第三行的空位可以在任意时刻放置，只需考虑中间的空位。对于中间有棋子的，它的左右两边是独立的，分开计算最后计算排列即可，所以只需考虑中间都是空的连续段。</p><p>显然要 DP，考虑记录中间的空位放置的时刻和放置方式，记 $f(i,j,0/1)$ 为枚举到第 $i$ 列，中间的空位在 $j$ 时放置，放置方式为上下/左右。</p><p>转移有 $0 \gets 0,0 \gets 1,1 \gets 0$ 三种情况，记 $c$ 为第 $i$ 列上下的空格数，$cnt_i$ 为 $i$ 列及以前的空格数，为不算重强制能上下放就上下放。</p><script type="math/tex; mode=display">f(i,j,0) \gets c! \binom{j-1}{c} \sum f(i-1,j',0) \\f(i,j,0) \gets c! \binom{j-1}{c} \sum_{j'+c \ge j} f(i-1,j',1) \\f(i,j+x,1) \gets c! \binom{j+x-1}{j-1} \binom{cnt_i-j-x}{c-x} \sum_{j' < j} f(i-1,j',0) \quad \texttt{for} \quad x \in [0,c)</script><p>其中第三种情况的思考方式是先放入中间的空格，再放入上下的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e3</span><span class="number">+10</span>,INF=<span class="number">1e9</span>,MOD=<span class="number">1e9</span><span class="number">+7</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">mod</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123; <span class="keyword">if</span>(x&gt;=MOD) x-=MOD; <span class="keyword">if</span>(x&lt;<span class="number">0</span>) x+=MOD; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">qm</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y=MOD<span class="number">-2</span>)</span></span>&#123; <span class="type">int</span> res=<span class="number">1</span>; <span class="keyword">for</span>(;y;y&gt;&gt;=<span class="number">1</span>,x=<span class="number">1ll</span>*x*x%MOD) <span class="keyword">if</span>(y&amp;<span class="number">1</span>) res=<span class="number">1ll</span>*res*x%MOD; <span class="keyword">return</span> res; &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> gc getchar()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rd read()</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,f=<span class="number">0</span>; <span class="type">char</span> c=gc;</span><br><span class="line">    <span class="keyword">for</span>(;c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>;c=gc) f|=(c==<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span>(;c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>;c=gc) x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(c^<span class="number">48</span>);</span><br><span class="line">    <span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> jc[N*<span class="number">3</span>],fjc[N*<span class="number">3</span>];</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> _init(<span class="type">int</span> n)&#123;</span><br><span class="line">    jc[<span class="number">0</span>]=<span class="number">1</span>; <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i) jc[i]=<span class="number">1ll</span>*jc[i<span class="number">-1</span>]*i%MOD;</span><br><span class="line">    fjc[n]=<span class="built_in">qm</span>(jc[n]); <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;~i;--i) fjc[i]=<span class="number">1ll</span>*fjc[i<span class="number">+1</span>]*(i<span class="number">+1</span>)%MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">C</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span>&#123; <span class="keyword">return</span> m&gt;n||n&lt;<span class="number">0</span>||m&lt;<span class="number">0</span>?<span class="number">0</span>:<span class="number">1ll</span>*jc[n]*fjc[m]%MOD*fjc[n-m]%MOD; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">P</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span>&#123; <span class="keyword">return</span> m&gt;n||n&lt;<span class="number">0</span>||m&lt;<span class="number">0</span>?<span class="number">0</span>:<span class="number">1ll</span>*jc[n]*fjc[n-m]%MOD; &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,all=<span class="number">0</span>,f[N*<span class="number">3</span>][<span class="number">2</span>],g[N*<span class="number">3</span>][<span class="number">2</span>],ans=<span class="number">1</span>,cnt=<span class="number">0</span>; <span class="type">char</span> s[<span class="number">3</span>][N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">chk</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s[<span class="number">0</span>][<span class="number">1</span>]==<span class="string">&#x27;x&#x27;</span>||s[<span class="number">2</span>][<span class="number">1</span>]==<span class="string">&#x27;x&#x27;</span>||s[<span class="number">0</span>][n]==<span class="string">&#x27;x&#x27;</span>||s[<span class="number">2</span>][n]==<span class="string">&#x27;x&#x27;</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[<span class="number">0</span>][i]==<span class="string">&#x27;x&#x27;</span>&amp;&amp;s[<span class="number">0</span>][i<span class="number">+1</span>]==<span class="string">&#x27;x&#x27;</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(s[<span class="number">2</span>][i]==<span class="string">&#x27;x&#x27;</span>&amp;&amp;s[<span class="number">2</span>][i<span class="number">+1</span>]==<span class="string">&#x27;x&#x27;</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">    all=(s[<span class="number">0</span>][i]==<span class="string">&#x27;x&#x27;</span>)+(s[<span class="number">2</span>][i]==<span class="string">&#x27;x&#x27;</span>)<span class="number">+1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=all;++j) f[j][<span class="number">0</span>]=f[j][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    f[all][<span class="number">0</span>]=jc[all<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;all;++i) f[i][<span class="number">1</span>]=jc[all<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=all;++j) <span class="built_in">mod</span>(g[j][<span class="number">0</span>]=g[j<span class="number">-1</span>][<span class="number">0</span>]+f[j][<span class="number">0</span>]),<span class="built_in">mod</span>(g[j][<span class="number">1</span>]=g[j<span class="number">-1</span>][<span class="number">1</span>]+f[j][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> c=(s[<span class="number">0</span>][i]==<span class="string">&#x27;x&#x27;</span>)+(s[<span class="number">2</span>][i]==<span class="string">&#x27;x&#x27;</span>); all+=c<span class="number">+1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=all;++j) f[j][<span class="number">0</span>]=f[j][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=c<span class="number">+1</span>;j&lt;=all;++j) <span class="built_in">mod</span>(f[j][<span class="number">0</span>]+=<span class="number">1ll</span>*<span class="built_in">P</span>(j<span class="number">-1</span>,c)*g[all-c<span class="number">-1</span>][<span class="number">0</span>]%MOD);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=c<span class="number">+1</span>;j&lt;=all;++j) <span class="built_in">mod</span>(f[j][<span class="number">0</span>]+=<span class="number">1ll</span>*<span class="built_in">P</span>(j<span class="number">-1</span>,c)*(g[all-c<span class="number">-1</span>][<span class="number">1</span>]-g[j-c<span class="number">-1</span>][<span class="number">1</span>])%MOD);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">0</span>;x&lt;c;++x) <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=all-c;++j) <span class="built_in">mod</span>(f[j+x][<span class="number">1</span>]+=<span class="number">1ll</span>*jc[c]*<span class="built_in">C</span>(j+x<span class="number">-1</span>,j<span class="number">-1</span>)%MOD*<span class="built_in">C</span>(all-j-x,c-x)%MOD*g[j<span class="number">-1</span>][<span class="number">0</span>]%MOD);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=all;++j) <span class="built_in">mod</span>(g[j][<span class="number">0</span>]=g[j<span class="number">-1</span>][<span class="number">0</span>]+f[j][<span class="number">0</span>]),<span class="built_in">mod</span>(g[j][<span class="number">1</span>]=g[j<span class="number">-1</span>][<span class="number">1</span>]+f[j][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    n=rd,<span class="built_in">scanf</span>(<span class="string">&quot;%s %s %s&quot;</span>, s[<span class="number">0</span>]<span class="number">+1</span>, s[<span class="number">1</span>]<span class="number">+1</span>, s[<span class="number">2</span>]<span class="number">+1</span>);</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">chk</span>()) <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;0\n&quot;</span>),<span class="number">0</span>; _init(n*<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j;i&lt;=n;i=j)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[<span class="number">1</span>][i]==<span class="string">&#x27;o&#x27;</span>) cnt+=(s[<span class="number">0</span>][i]==<span class="string">&#x27;x&#x27;</span>)+(s[<span class="number">2</span>][i]==<span class="string">&#x27;x&#x27;</span>),j=i<span class="number">+1</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(j=i;j&lt;=n&amp;&amp;s[<span class="number">1</span>][j]==s[<span class="number">1</span>][i];++j);</span><br><span class="line">            <span class="built_in">init</span>(i); <span class="keyword">for</span>(<span class="type">int</span> k=i<span class="number">+1</span>;k&lt;j;++k) <span class="built_in">get</span>(k);</span><br><span class="line">            ans=<span class="number">1ll</span>*(g[all][<span class="number">0</span>]+g[all][<span class="number">1</span>])%MOD*ans%MOD*fjc[all]%MOD,cnt+=all;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans=<span class="number">1ll</span>*ans*jc[cnt]%MOD;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> solutions </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>支配树</title>
      <link href="/notes/dom/"/>
      <url>/notes/dom/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>对于有向图 $G=(V,E)$，在给定源点 $s \in V$（$s$ 可达 $V$ 中其他节点）的情况下，若任意 $s \to y$ 的路径都经过 $x$，则称 $x$ 支配 $y$，$x$ 是 $y$ 的支配点，记作 $x=dom_y$。支配关系满足传递性、自反性、反对称性，是偏序关系，偏序关系可以用 DAG 刻画。</p><p>支配关系还满足若 $x = dom_z,y = dom_z$ 则 $x=dom_y$ 或 $y = dom_x$。满足这个性质的偏序关系可以用树刻画。记 $idom_x$ 为 $x$ 的直接支配点（不为 $x$），满足若 $y=dom_x,y \ne x$ 那么 $y=dom_{idom_x}$，直观理解就是支配点中离 $x$ 最近的那个。$idom_x \to x$ 可以得到一棵树，称为支配树。</p><h2 id="DAG"><a href="#DAG" class="headerlink" title="DAG"></a><a href="https://www.luogu.com.cn/problem/P2597">DAG</a></h2><p>求解 DAG 的支配树，有一个简单的算法。</p><p>拓扑排序，按拓扑序从小到大求解。对于点 $x$，DAG 上以其为终点的边有 $(s_1,x),(s_2,x)…$，则其直接支配点为 $LCA(s_1,s_2,…)$。</p><p>需要添加叶子节点求 LCA，用倍增求解，时间复杂度 $O((n+m)\log n)$。</p><h2 id="一般图"><a href="#一般图" class="headerlink" title="一般图"></a><a href="https://www.luogu.com.cn/problem/P5180">一般图</a></h2><p>先求出 dfs 树，$x&lt;y$ 当且仅当 $dfn_x&lt;dfn_y$，记 $[x,y]$ 为树上 $x$ 到 $y$ 路径上的点（$(x,y)$ 同理）。</p><blockquote><p><strong>引理 1</strong> $idom_u$ 是 $u$ 的真祖先（不含 $u$ 的祖先）。</p><p>证明显然。</p></blockquote><p>记 $lca$ 为 $lca(u,v)$。</p><blockquote><p><strong>引理 2</strong> 若 $u &lt; v$，那么任意 $u$ 到 $v$ 的路径一定经过 $lca$ 的祖先。</p><p>横叉边满足从大到小，可以感性理解。</p></blockquote><p>那么一定存在祖先节点使得其可以通过大于 $x$ 的节点到达 $x$，记为 $y$，而 $(y,x)$ 都不能作为 $idom_x$。只需要考虑满足该性质的最小的祖先即可。</p><blockquote><p><strong>半支配点</strong> 存在路径 $y \to p_1 \to p_2 \to … \to x,p_i &gt; x$ 的最小的 $x$ 的祖先 $y$ 称为 $x$ 的半支配点，记作 $sdom_x$。</p></blockquote><p>考虑通过半支配点求得直接支配点。记 $p_x$ 为 $(sdom_x,x)$ 上 $sdom$ 最小的点，有</p><script type="math/tex; mode=display">idom_x = \begin{cases}  sdom_x  & \text{ if } sdom_{p_x} > sdom_x\\  idom_{p_x}  & \text{ otherwise }\end{cases}</script><p>考虑将 $idom_x$ 的求解挂在 $sdom_x$ 上。遍历 dfs 树，用带权并查集维护每个点到当前节点 $sdom$ 最小的点，直接查询即可。最后按 $dfs$ 序从大到小计算 $idom$。时间复杂度 $O(n \log n)$。</p><p>考虑求解半支配点。设求解 $sdom_x$，分类讨论</p><ul><li><p>对于树边或前向边 $y \to x$，用 $y$ 更新 $sdom_x$。</p></li><li><p>对于中间有点的路径，枚举 $y \to x$ 作为最后一条边。</p><p>直接用 $sdom_y$ 更新是不对的，因为 $sdom_x$ 到 $x$ 可能存在点 $p$ 满足 $x &lt; p &lt; y$。</p><p>记 $z$ 为 $sdom_x$ 到 $x$ 上最小的点，根据引理 2，$z$ 一定是 $y$ 的祖先。只需考虑 $z$ 在 $[lca(x,y),y)$ 上的情况即可，否则可以通过树边到达 $x$。用 $sdom_z$ 更新 $sdom_x$ 即可。</p><p>实现与求解直接支配点相同，用一个并查集即可，具体见代码。</p></li></ul><p>时间复杂度 $O(n \log n)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n,m;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; G[N],FG[N],TG[N],vc[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dfn[N],d_c=<span class="number">0</span>,fdfn[N],vis[N],sdom[N],idom[N],pos[N],siz[N];     </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fu)</span></span>&#123; fdfn[dfn[u]=++d_c]=u,vis[u]=<span class="number">1</span>; <span class="keyword">for</span>(<span class="type">int</span> v:G[u]) <span class="keyword">if</span>(!vis[v]) <span class="built_in">dfs</span>(v,u),TG[u].<span class="built_in">pb</span>(v); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DSU</span>&#123;</span><br><span class="line">    <span class="type">int</span> fa[N],mn[N];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span>&#123; <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i) fa[i]=i,mn[i]=i; &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x==fa[x]) <span class="keyword">return</span> x; <span class="type">int</span> res=<span class="built_in">find</span>(fa[x]);</span><br><span class="line">        <span class="keyword">if</span>(dfn[sdom[mn[fa[x]]]]&lt;dfn[sdom[mn[x]]]) mn[x]=mn[fa[x]];</span><br><span class="line">        <span class="keyword">return</span> fa[x]=res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;D;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    dfn[sdom[u]]=INF;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v:FG[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(dfn[v]&lt;dfn[u])&#123; <span class="keyword">if</span>(dfn[v]&lt;dfn[sdom[u]]) sdom[u]=v; &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123; D.<span class="built_in">find</span>(v); <span class="keyword">if</span>(dfn[sdom[D.mn[v]]]&lt;dfn[sdom[u]]) sdom[u]=sdom[D.mn[v]]; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vc[sdom[u]].<span class="built_in">pb</span>(u);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v:vc[u]) D.<span class="built_in">find</span>(v),pos[v]=D.mn[v];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v:TG[u]) D.fa[v]=u; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    n=rd,m=rd,D.<span class="built_in">init</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,x,y;i&lt;=m;++i) G[x=rd].<span class="built_in">pb</span>(y=rd),FG[y].<span class="built_in">pb</span>(x);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>); <span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;--i) <span class="built_in">sol</span>(fdfn[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(pos[fdfn[i]]==fdfn[i]) idom[fdfn[i]]=sdom[fdfn[i]];</span><br><span class="line">        <span class="keyword">else</span> idom[fdfn[i]]=idom[pos[fdfn[i]]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h4 id="1-点集的支配点"><a href="#1-点集的支配点" class="headerlink" title="1.点集的支配点"></a>1.点集的支配点</h4><p>求点集在支配树上的 LCA 即可。</p><h4 id="2-支配边"><a href="#2-支配边" class="headerlink" title="2.支配边"></a>2.支配边</h4><p>显然可以可以对每条边建立虚点。但此方法常数较大，有常数更小的做法。</p><blockquote><p><strong>引理 3</strong> $(u,v)$ 是点 $x$ 的支配边当且仅当 $u,v$ 都是 $x$ 的支配点且 $u$ 到 $v$ 只有一条简单路径。</p><p>证明显然。</p></blockquote><p>支配边显然是树边，对于树边 $(u,v)$，若 $u=idom_v$ 且 $u$ 到 $v$ 只有一条简单路径，那么 $(u,v)$ 支配 $v$ 支配的所有点。</p><p>对于树边 $(u,v)$ 且 $u=idom_v$，$u$ 到 $v$ 只有一条简单路径当且仅当计算 $sdom_v$ 时只有一种情况使得 $sdom=u$（注意重边）。</p><h4 id="3-有向图的割点和割边"><a href="#3-有向图的割点和割边" class="headerlink" title="3.有向图的割点和割边"></a>3.有向图的割点和割边</h4><p>类似无向图，有向图的割点和割边为删去后强连通分量增加的点和边，称为强割点和强割边。</p><p>可以对每个强连通分量分别考虑，因此以下讨论均基于强连通图。</p><blockquote><p><strong>引理 4.1</strong> 点 $x$ 是强割点当且仅当对于任意 $u \ne x$，都存在点 $v \ne x$，使得以下之一成立：</p><ul><li>任意 $u$ 到 $v$ 的路径都经过 $x$。</li><li>任意 $v$ 到 $u$ 的路径都经过 $x$。</li></ul><p><strong>引理 4.2</strong> 边 $(x,y)$ 是强割边当且仅当对于任意 $u$ 都存在点 $v$ 使得以下之一成立：</p><ul><li>任意 $u$ 到 $v$ 的路径都经过边 $(x,y)$。</li><li>任意 $v$ 到 $u$ 的路径都经过边 $(x,y)$。</li></ul><p>证明显然。</p></blockquote><p>记 $DT(G,s)$ 为图 $G$ 以 $s$ 为源点的支配树。</p><p>任取一点 $s$，并判断它是否为强割点。根据条件 1，$DT(G,s)$ 除 $s$ 外的非叶子节点都是强割点，根据条件 2，$DT(G^{-1},s)$ 除 $s$ 外的非叶子节点都是强割点。</p><p>强割边判断同支配边。</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h4 id="1-Team-Rocket-Rises-Again"><a href="#1-Team-Rocket-Rises-Again" class="headerlink" title="1.Team Rocket Rises Again"></a><a href="https://www.luogu.com.cn/problem/CF757F">1.Team Rocket Rises Again</a></h4><p>先求最短路 DAG，再求支配树即可。</p><h4 id="2-省选联考-2021-A-卷-支配"><a href="#2-省选联考-2021-A-卷-支配" class="headerlink" title="2.[省选联考 2021 A 卷] 支配"></a><a href="https://www.luogu.com.cn/problem/P7520">2.[省选联考 2021 A 卷] 支配</a></h4><p>先求支配树，只需判断是否存在 $1 \leadsto x \to y \leadsto p$ 且不经过 $idom_p$ 的路径即可，时间复杂度 $O(n^2+nq)$。</p><h4 id="3-【R1-B】地铁线路"><a href="#3-【R1-B】地铁线路" class="headerlink" title="3.【R1-B】地铁线路"></a>3.【R1-B】地铁线路</h4><p>求强割边。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《浅谈支配树及其应用》</p>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>P3175 [HAOI2015] 按位或</title>
      <link href="/solutions/P3175/"/>
      <url>/solutions/P3175/</url>
      
        <content type="html"><![CDATA[<blockquote><p>你手上有一个数，初始为 $0$，每秒随机选择一个 $[0,2^n)$ 的数与你手上的数或，选择 $i$ 的概率为 $p_i$，求你手上的数变为 $2^n - 1$ 的期望时间。</p><p>$1 \le n \le 20$。</p></blockquote><h2 id="法一"><a href="#法一" class="headerlink" title="法一"></a>法一</h2><p>min-max 容斥，直接背式子</p><script type="math/tex; mode=display">\mathrm{kthmax}(S) = \sum_{T \subseteq S} (-1)^{|T|-1} \binom{|T|-1}{k-1} \min(T)</script><p>期望意义下也是成立的，证明比较扭曲。</p><p>记 $f_{i}$ 为第 $i$ 位变为 $1$ 的时间，套 min-max 容斥即可。</p><h2 id="法二"><a href="#法二" class="headerlink" title="法二"></a>法二</h2><p>定义乘法为或卷积，那么 $k$ 秒后手上的数为 $S$ 的概率为 $p^{k}_{S}$。记 $f_{S}$ 为数为 $S$ 的期望时间，那么</p><script type="math/tex; mode=display">f_{S} = \sum_{k=1}^{\infty} k(p^{k}_{S} - p^{k-1}_{S})</script><p>记 $f,p$ 莫比乌斯变换的结果为 $F,P$，那么</p><script type="math/tex; mode=display">\begin{aligned}F_{S} &= \sum_{k=1}^{\infty} k(P^{k}_{S} - P^{k-1}_{S}) \\&= -\sum_{k=0}^{\infty} P_{S}^{k} \\&=\left\{\begin{matrix} -\frac{1}{1-P_{S}} & (P_S \neq 1) \\ 0 & (P_S=1)\end{matrix}\right.\end{aligned}</script>]]></content>
      
      
      <categories>
          
          <category> solutions </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>集合幂级数</title>
      <link href="/notes/FWT/"/>
      <url>/notes/FWT/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><script type="math/tex; mode=display">(x \oplus y) \& z = (x \& z) \oplus (y \& z)</script><script type="math/tex; mode=display">\frac{1}{2^{n}} \sum_{T < 2^n} (-1)^{|S \& T|} = [S=0]</script><p>得到</p><script type="math/tex; mode=display">\begin{aligned}h_{S} &= \sum_{L \oplus R = S} f_{L}g_{R} \\&= \sum [L \oplus R \oplus S = 0]f_{L}g_{R} \\&= \sum \frac{1}{2^n} \sum_{T < 2^n} (-1)^{|(L \oplus R \oplus S) \& T|} f_{L}g_{R} \\&= \sum \frac{1}{2^n} \sum_{T < 2^n} (-1)^{|L \& T|}(-1)^{|R \& T|}(-1)^{|S \& T|}f_{L}g_{R} \\&= \frac{1}{2^n} \sum_{T < 2^n} (-1)^{|S \& T|} (\sum_{L < 2^n}(-1)^{|L \& T|}f_{L})(\sum_{R < 2^n}(-1)^{|R \& T|}g_{R})\end{aligned}</script><p>定义沃尔什变换为</p><script type="math/tex; mode=display">f_{S} = \sum_{T < 2^n} (-1)^{|S \& T|} f_{T}</script><p>其逆变换为</p><script type="math/tex; mode=display">f_{S} = \sum_{T < 2^n} (-1)^{|S \& T|} f_{T}</script><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">OR</span><span class="params">(<span class="type">int</span> A[N],<span class="type">int</span> op)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> mid=<span class="number">1</span>;mid&lt;(<span class="number">1</span>&lt;&lt;n);mid&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;n);i+=(mid&lt;&lt;<span class="number">1</span>))</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;i+mid;++j)</span><br><span class="line">                <span class="built_in">mod</span>(A[j+mid]=op*A[j]+A[j+mid]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AND</span><span class="params">(<span class="type">int</span> A[N],<span class="type">int</span> op)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> mid=<span class="number">1</span>;mid&lt;(<span class="number">1</span>&lt;&lt;n);mid&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;n);i+=(mid&lt;&lt;<span class="number">1</span>))</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;i+mid;++j)</span><br><span class="line">                <span class="built_in">mod</span>(A[j]=A[j]+op*A[j+mid]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">XOR</span><span class="params">(<span class="type">int</span> A[N],<span class="type">int</span> op)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> mid=<span class="number">1</span>,A0,A1;mid&lt;(<span class="number">1</span>&lt;&lt;n);mid&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;n);i+=(mid&lt;&lt;<span class="number">1</span>))</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;i+mid;++j)&#123;</span><br><span class="line">                A0=A[j],A1=A[j+mid];</span><br><span class="line">                <span class="built_in">mod</span>(A[j]=A0+A1),<span class="built_in">mod</span>(A[j+mid]=A0-A1);</span><br><span class="line">                <span class="keyword">if</span>(op==<span class="number">-1</span>) A[j]=<span class="number">1ll</span>*A[j]*inv2%MOD,A[j+mid]=<span class="number">1ll</span>*A[j+mid]*inv2%MOD;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Nim"><a href="#Nim" class="headerlink" title="Nim"></a>Nim</h2><blockquote><p>nim 游戏，有 $n$ 堆石子，求每堆石子为不超过 $m$ 的素数且先手必败的方案数。</p><p>$1 \le n \le 10^9,1 \le m \le 10^5$。</p></blockquote><p>先手必败当且仅当异或和为 $0$。FWT 即可，时间复杂度 $O(m\log m + m\log n)$。</p><h2 id="连通生成子图计数"><a href="#连通生成子图计数" class="headerlink" title="连通生成子图计数"></a>连通生成子图计数</h2><blockquote><p>给你 $n$ 个节点的无向图 $G$，求连通生成子图个数，答案对 $10^9 + 7$ 取模。</p><p>$1 \le n \le 20$。 </p></blockquote><p>记 $f$ 为连通生成子图的集合幂级数，$g$ 为生成子图的集合幂级数，令$f_{\emptyset}=g_{\emptyset}=0$，$g$ 是好求的。定义乘法为子集卷积，那么 $g = \sum_{i \ge 1} \frac{f^{i}}{i!} = e^f -1$，即 $f = \ln(g+1)$。</p><h2 id="线性基"><a href="#线性基" class="headerlink" title="线性基"></a>线性基</h2><blockquote><p>对每个 $S \in [0,2^n)$，求 $\sum [\bigoplus_{x \in T}x = S] \prod_{x \in T} a_x \prod_{x \notin T} b_x$。</p><p>$1 \le n \le 20$。</p></blockquote><p>定义乘法为异或卷积，即求 $\prod (a_i + b_i x^i)$ 的各项系数。</p><p>FWT，定义乘法为对应相乘，转化为 $\mathrm{IFWT} (\prod \mathrm{FWT} (a_i + b_ix^i))$。根据定义</p><script type="math/tex; mode=display">\begin{aligned}\prod \mathrm{FWT} (a_i + b_ix^i) &= \prod_{i} \sum_{j < 2^n} (a_i+(-1)^{|j \& i|} b_i)x^j \\&= \sum_{j < 2^n} x^j \prod_{i} (a_i + (-1)^{|j \& i|}b_i)\end{aligned}</script><p>即对每个 $S \in [0,2^n)$ 求出 $\prod_{i}(a_i + (-1)^{|S \&amp; i|}b_i)$。按位考虑，记 $f_{k,S}$ 为满足 $i \oplus S \in [0,2^k)$ 的 $i$ 的上式的值。</p>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>P6631 [ZJOI2020] 序列</title>
      <link href="/solutions/P6631/"/>
      <url>/solutions/P6631/</url>
      
        <content type="html"><![CDATA[<blockquote><p>给你一个长为 $n$ 的非负整数序列 $a$，你可以进行区间减 $1$，区间奇数下标减 $1$，区间偶数下标减 $1$，请求出讲所有数变为 $0$ 的最小操作次数。</p><p>$1 \le n \le 10^5$。</p></blockquote><p>记 $m$ 为操作种类数，$S_i$ 为第 $i$ 种操作涉及的下标集合，$x_i$ 为第 $i$ 种操作的操作次数，那么可以写成</p><script type="math/tex; mode=display">\begin{aligned}\min \quad &\sum_{j=1}^{m} x_j \\\texttt{s.t.} \quad&\sum_{j=1}^{m} [i \in S_j]x_j = a_i \quad i=1,2,...,n \\&x_j \ge 0 \quad j=1,2,...,m\end{aligned}</script><p>对每个限制设一个乘数 $p_i$，加入最小化的式子中得到</p><script type="math/tex; mode=display">\begin{aligned}&\sum_{j=1}^{m} x_j + \sum_{i=1}^{n} p_i (\sum_{j=1}^{m} [i \in S_j]x_i - a_i) \\&=\sum_{j=1}^{m} (\sum_{i \in S_j} p_i + 1) x_j - \sum_{i=1}^{n} p_ia_i\end{aligned}</script><p>拉格朗日对偶，并将 $p_i$ 取反，得到</p><script type="math/tex; mode=display">\begin{aligned}\max \quad &\sum_{i=1}^{n} p_ia_i \\\texttt{s.t.} \quad&\sum_{i \in S_j} p_i \le 1 \quad j=1,2,...,m \\\end{aligned}</script><p>描述一下就是求出一个序列 $p$ 使得每个可以一起操作的下标集合 $p$ 之和都 $\le 1$，求 $\sum_{i=1}^{n} a_ip_i$ 的最大值。</p><p>猜测有整数最优解。假设一个合法的 $p$ 有 $\le -2$ 的数，那么将其改为 $-1$ 仍然合法并且不劣。限制 $p$ 只能取 $-1,0,1$ 即可。</p><p>考虑 DP，记 $f_{i,0/1,0/1,0/1}$ 为枚举到 $i$，是否有和为 $1$ 的后缀，是否有后缀满足下标为偶数的和为 $1$，奇数，的最大值。转移枚举当前位选择 $-1,0,1$ 即可。时间复杂度 $O(n)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+100</span>,INF=<span class="number">1e18</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">in</span><span class="params">(<span class="type">int</span> S,<span class="type">int</span> i)</span></span>&#123; <span class="keyword">return</span> (S&gt;&gt;i)&amp;<span class="number">1</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">chkmax</span><span class="params">(<span class="type">int</span> &amp;x,<span class="type">int</span> y)</span></span>&#123; <span class="keyword">return</span> y&gt;x?x=y,<span class="number">1</span>:<span class="number">0</span>; &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> gc getchar()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rd read()</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,f=<span class="number">0</span>; <span class="type">char</span> c=gc;</span><br><span class="line">    <span class="keyword">for</span>(;c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>;c=gc) f|=(c==<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span>(;c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>;c=gc) x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(c^<span class="number">48</span>);</span><br><span class="line">    <span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,a[N],f[N][<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=rd; <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i) a[i]=rd;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;++i) <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">8</span>;++j) f[i][j]=-INF; f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">8</span>;++j)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> x:&#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>&#125;)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">in</span>(j,<span class="number">0</span>)==<span class="number">1</span>&amp;&amp;x==<span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(i&amp;<span class="number">1</span>)&#123; <span class="keyword">if</span>(x!=<span class="number">1</span>||!<span class="built_in">in</span>(j,<span class="number">2</span>)) <span class="built_in">chkmax</span>(f[i][(<span class="built_in">in</span>(j,<span class="number">0</span>)+x==<span class="number">1</span>)|(<span class="built_in">in</span>(j,<span class="number">1</span>)&lt;&lt;<span class="number">1</span>)|((<span class="built_in">in</span>(j,<span class="number">2</span>)+x==<span class="number">1</span>)&lt;&lt;<span class="number">2</span>)],f[i<span class="number">-1</span>][j]+x*a[i]); &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123; <span class="keyword">if</span>(x!=<span class="number">1</span>||!<span class="built_in">in</span>(j,<span class="number">1</span>)) <span class="built_in">chkmax</span>(f[i][(<span class="built_in">in</span>(j,<span class="number">0</span>)+x==<span class="number">1</span>)|((<span class="built_in">in</span>(j,<span class="number">1</span>)+x==<span class="number">1</span>)&lt;&lt;<span class="number">1</span>)|(<span class="built_in">in</span>(j,<span class="number">2</span>)&lt;&lt;<span class="number">2</span>)],f[i<span class="number">-1</span>][j]+x*a[i]); &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>; <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;++i) <span class="built_in">chkmax</span>(ans,f[n][i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> T=rd;</span><br><span class="line">    <span class="keyword">while</span>(T--) <span class="built_in">solve</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> solutions </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>AGC025F Addition and Andition</title>
      <link href="/solutions/AGC025F/"/>
      <url>/solutions/AGC025F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>给定两个长为 $n,m$ 的二进制串 $x,y$，有 $k$ 次操作，每次令 $x,y$ 同时加上 $x\&amp;y$，求最后的 $x,y$。</p><p>$1 \le n,m,k \le 10^6$。</p></blockquote><p>直接模拟可以做到 $O((n+m)k)$。</p><p>可以手玩几组观察性质，发现只会移动 $x_i=y_i=1$ 的位置，并且它们之间是独立的，简单来说就是不会撞到一起。考虑从高位到低位考虑这样的位置（因为高位的“足迹”会对低位产生影响）。</p><p>对于 $x_i=y_i=1$ 的 $i$，按 $i+1$ 位分讨</p><ul><li><p>$x_{i+1}=y_{i+1}=0$，相当于 $i$ 位的 $1$ 移动一步。</p></li><li><p>$x_{i+1}=y_{i+1}=1$，不可能存在。</p></li><li><p>其他，当前位的 $1$ 会向前跳跃几步（根据连续 $1$ 的个数）。</p></li></ul><p>对于第三种情况，可以直接将当前位清空，下一位加 $1$，在下一位再处理进位，在当前位步数加 $1$（进位的位步数不加）。</p><p>发现每次进行进位 $1$ 的个数都会减少，那么进位只会进行 $O(n+m)$ 次。而第一种情况很好缩在一起，那么得出了 $O(n+m+k)$ 的模拟做法。</p><p>具体的，从高位到低位枚举，将 $x/y$ 非空的位加入栈中，当枚举到 $x=y=1$ 的位时进行上述模拟，具体细节见代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span><span class="number">+100</span>,INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> gc getchar()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rd read()</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,f=<span class="number">0</span>; <span class="type">char</span> c=gc;</span><br><span class="line">    <span class="keyword">for</span>(;c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>;c=gc) f|=(c==<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span>(;c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>;c=gc) x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(c^<span class="number">48</span>);</span><br><span class="line">    <span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,K,a[N*<span class="number">2</span>],b[N*<span class="number">2</span>],sta[N*<span class="number">2</span>],tp=<span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> s[N],t[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vc;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    n=rd,m=rd,K=rd,<span class="built_in">scanf</span>(<span class="string">&quot;%s %s&quot;</span>, s<span class="number">+1</span>, t<span class="number">+1</span>);</span><br><span class="line">    <span class="built_in">reverse</span>(s<span class="number">+1</span>,s+n<span class="number">+1</span>),<span class="built_in">reverse</span>(t<span class="number">+1</span>,t+m<span class="number">+1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="built_in">max</span>(n,m);++i) a[i]=(i&lt;=n?s[i]-<span class="string">&#x27;0&#x27;</span>:<span class="number">0</span>),b[i]=(i&lt;=m?t[i]-<span class="string">&#x27;0&#x27;</span>:<span class="number">0</span>);</span><br><span class="line">    sta[tp=<span class="number">1</span>]=INF;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="built_in">max</span>(n,m);i&gt;=<span class="number">1</span>;--i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!a[i]&amp;&amp;!b[i]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a[i]&amp;&amp;b[i])&#123;</span><br><span class="line">            vc=&#123;&#125;;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i,c=K;;)&#123;</span><br><span class="line">                vc.<span class="built_in">pb</span>(j);</span><br><span class="line">                <span class="keyword">for</span>(;tp&amp;&amp;sta[tp]&lt;=j;--tp);</span><br><span class="line">                <span class="keyword">if</span>(a[j]==<span class="number">1</span>&amp;&amp;b[j]==<span class="number">1</span>&amp;&amp;c)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(tp&amp;&amp;sta[tp]==j<span class="number">+1</span>) a[j]=b[j]=<span class="number">0</span>,++a[j<span class="number">+1</span>],++b[j<span class="number">+1</span>],--c,++j;</span><br><span class="line">                    <span class="keyword">else</span>&#123; a[j]=b[j]=<span class="number">0</span>; <span class="type">int</span> jp=<span class="built_in">min</span>(c,sta[tp]-j<span class="number">-1</span>); c-=jp,j+=jp; a[j]=b[j]=<span class="number">1</span>; &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(a[j]&gt;<span class="number">1</span>||b[j]&gt;<span class="number">1</span>)&#123;</span><br><span class="line">                    a[j<span class="number">+1</span>]+=a[j]/<span class="number">2</span>,a[j]&amp;=<span class="number">1</span>;</span><br><span class="line">                    b[j<span class="number">+1</span>]+=b[j]/<span class="number">2</span>,b[j]&amp;=<span class="number">1</span>;</span><br><span class="line">                    ++j;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">reverse</span>(vc.<span class="built_in">begin</span>(),vc.<span class="built_in">end</span>());</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> v:vc) <span class="keyword">if</span>(a[v]||b[v]) sta[++tp]=v;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> sta[++tp]=i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">reverse</span>(a<span class="number">+1</span>,a+n+K<span class="number">+1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,flag=<span class="number">0</span>;i&lt;=n+K;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!a[i]&amp;&amp;!flag) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, a[i]); flag=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="built_in">reverse</span>(b<span class="number">+1</span>,b+m+K<span class="number">+1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,flag=<span class="number">0</span>;i&lt;=m+K;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!b[i]&amp;&amp;!flag) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, b[i]); flag=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> solutions </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CF1086F Forest Fires</title>
      <link href="/solutions/CF1086F/"/>
      <url>/solutions/CF1086F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>无限大的网格，第 $0$ 秒有 $n$ 个点燃烧，每一秒正燃烧的点会使与其八连通的点燃烧，每个点的权值为其最早燃烧的时间，求 $t$ 秒后的权值和。</p><p>$1 \le n \le 2000,1 \le t \le 10^8,-10^8 \le x,y \le 10^8$。</p></blockquote><p>记 $f_i$ 为 $i$ 秒后燃烧格子的数量，那么答案为</p><script type="math/tex; mode=display">tf_t - \sum_{i=0}^{t-1} f_i</script><p>$f_i$ 可用扫描线 $O(n\log n)$ 求解，可以求出所有 $f_i$ 代入上式获得答案，时间复杂度 $O(tn \log n)$。</p><p>由于每秒矩形都会扩大 $1$，并且所有矩形的大小相等，那么猜测 $f_i$ 与 $i$ 成某个简单的函数关系。矩形并的轮廓线的大小即为 $f_i$ 的增大量，发现轮廓线的大小成等差数列。准确来说，当矩形的相交关系不变时，$f_i$ 为关于 $i$ 的二次函数。总共有 $O(n^2)$ 种两两相交，它们将时间分成了 $O(n^2)$ 段，每段中 $f_i$ 的函数表达式不变。那么求出三个 $f_i$ 就可以得到本段中 $f_i$ 之和。时间复杂度 $O(n^3\log n)$。本方法足以通过 CF。</p><p>发现矩形的交是好求的，考虑容斥，记 $g_{S,i}$ 为集合 $S$ 中的初始点在 $i$ 秒后形成矩形的交的大小，那么答案为</p><script type="math/tex; mode=display">\sum_{S} (-1)^{|S|+1} (tg_{S,t} - \sum_{i=0}^{t-1} g_{S,i})</script><p>记 $dx,dy$ $S$ 中的点横纵坐标差的极大值，那么</p><script type="math/tex; mode=display">g_{S,i} = \max(0,2i+1-dx) \times \max(0,2i+1-dy)</script><p>通过推式子，$(-1)^{|S|+1}(tg_{S,t} - \sum_{i=0}^{t-1} g_{S,i})$ 可以 $O(1)$ 求解，记为 $G_S$。</p><p>进一步观察，若 $S$ 中存在一个点 $x$ 使得删去这个点后横纵坐标差的极大值不变，那么 $G_{S} + G_{S \setminus \{x\}} = 0$（符号相反），那么合法的 $S$ 大大减少，事实上只有 $O(n^2)$ 个。</p><p>将节点按横坐标排序，枚举 $i &lt; j$ 框定横坐标差的极大值。需要判断 $(i,j)$ 中是否存在点的纵坐标在 $i,j$ 纵坐标内，如果存在那么包含 $i,j$ 的集合都不合法，否则将 $G_{\{i,j\}}$ 计入答案，并找到 $(i,j)$ 中 $i,j$ 纵坐标的前驱/后继，枚举它们是否计入 $S$ 计入答案。用 <code>set</code> 实现，时间复杂度 $O(n^2\log n)$。用链表实现可以做到 $O(n^2)$。</p><p>有一个细节是对于横/纵坐标相等的点，发现怎样钦定它们的顺序都是对的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ar(x) array<span class="string">&lt;int,x&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e3</span><span class="number">+100</span>,INF=<span class="number">1e9</span>,MOD=<span class="number">998244353</span>,inv3=<span class="number">332748118</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">mod</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123; <span class="keyword">if</span>(x&gt;=MOD) x-=MOD; <span class="keyword">if</span>(x&lt;<span class="number">0</span>) x+=MOD; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">qm</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y=MOD<span class="number">-2</span>)</span></span>&#123; <span class="type">int</span> res=<span class="number">1</span>; <span class="keyword">for</span>(;y;y&gt;&gt;=<span class="number">1</span>,x=<span class="number">1ll</span>*x*x%MOD) <span class="keyword">if</span>(y&amp;<span class="number">1</span>) res=<span class="number">1ll</span>*res*x%MOD; <span class="keyword">return</span> res; &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> gc getchar()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rd read()</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,f=<span class="number">0</span>; <span class="type">char</span> c=gc;</span><br><span class="line">    <span class="keyword">for</span>(;c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>;c=gc) f|=(c==<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span>(;c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>;c=gc) x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(c^<span class="number">48</span>);</span><br><span class="line">    <span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,t,ans=<span class="number">0</span>; <span class="built_in">ar</span>(<span class="number">2</span>) a[N]; set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> i)</span></span>&#123; <span class="keyword">return</span> <span class="number">1ll</span>*<span class="built_in">max</span>(<span class="number">0</span>,(<span class="number">2</span>*i-x<span class="number">+1</span>))*<span class="built_in">max</span>(<span class="number">0</span>,(<span class="number">2</span>*i-y<span class="number">+1</span>))%MOD; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">S1</span><span class="params">(<span class="type">int</span> x)</span></span>&#123; <span class="keyword">return</span> <span class="number">1ll</span>*x*(x<span class="number">+1</span>)/<span class="number">2</span>%MOD; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">S2</span><span class="params">(<span class="type">int</span> x)</span></span>&#123; <span class="keyword">return</span> <span class="number">1ll</span>*x*(x<span class="number">+1</span>)/<span class="number">2</span>%MOD*(<span class="number">2</span>*x<span class="number">+1</span>)%MOD*inv3%MOD; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> res=<span class="number">1ll</span>*t*<span class="built_in">f</span>(x,y,t)%MOD,l=(<span class="built_in">max</span>(x,y)<span class="number">+1</span>)/<span class="number">2</span>,r=t<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span>(l&gt;r) <span class="keyword">return</span> res;</span><br><span class="line"><span class="built_in">mod</span>(res-=<span class="number">4ll</span>*(<span class="built_in">S2</span>(r)-<span class="built_in">S2</span>(l<span class="number">-1</span>))%MOD);</span><br><span class="line"><span class="built_in">mod</span>(res+=<span class="number">2ll</span>*(x<span class="number">-1</span>+y<span class="number">-1</span>)*(<span class="built_in">S1</span>(r)-<span class="built_in">S1</span>(l<span class="number">-1</span>))%MOD);</span><br><span class="line"><span class="built_in">mod</span>(res-=<span class="number">1ll</span>*(x<span class="number">-1</span>)*(y<span class="number">-1</span>)%MOD*(r-l<span class="number">+1</span>)%MOD);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> dx=a[j][<span class="number">0</span>]-a[i][<span class="number">0</span>],p=INF,q=INF;</span><br><span class="line">    <span class="keyword">if</span>(a[i][<span class="number">1</span>]&gt;a[j][<span class="number">1</span>]) <span class="built_in">swap</span>(i,j);</span><br><span class="line">    <span class="keyword">auto</span> it1=s.<span class="built_in">upper_bound</span>(a[j][<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">auto</span> it2=s.<span class="built_in">lower_bound</span>(a[i][<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span>(it1!=it2) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">mod</span>(ans-=<span class="built_in">calc</span>(dx,a[j][<span class="number">1</span>]-a[i][<span class="number">1</span>]));</span><br><span class="line">    <span class="keyword">if</span>(it1!=s.<span class="built_in">end</span>()) <span class="built_in">mod</span>(ans+=<span class="built_in">calc</span>(dx,*it1-a[i][<span class="number">1</span>])),p=*it1;</span><br><span class="line">    <span class="keyword">if</span>(it2!=s.<span class="built_in">begin</span>()) --it2,<span class="built_in">mod</span>(ans+=<span class="built_in">calc</span>(dx,a[j][<span class="number">1</span>]-*it2)),q=*it2;</span><br><span class="line">    <span class="keyword">if</span>(p!=INF&amp;&amp;q!=INF) <span class="built_in">mod</span>(ans-=<span class="built_in">calc</span>(dx,p-q));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=rd,t=rd,ans=<span class="number">1ll</span>*n*<span class="built_in">calc</span>(<span class="number">0</span>,<span class="number">0</span>)%MOD;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i) a[i]=&#123;rd,rd&#125;; <span class="built_in">sort</span>(a<span class="number">+1</span>,a+n<span class="number">+1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        s.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">+1</span>;j&lt;=n;++j)</span><br><span class="line">            <span class="built_in">solve</span>(i,j),s.<span class="built_in">insert</span>(a[j][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> T=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(T--) <span class="built_in">solve</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> solutions </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>AGC018E Sightseeing Plan</title>
      <link href="/solutions/AGC018E/"/>
      <url>/solutions/AGC018E/</url>
      
        <content type="html"><![CDATA[<blockquote><p>网格图上有三个矩形 ​​</p><script type="math/tex; mode=display">A:(x_1,y_1)-(x_2,y_2),B:(x_3,y_3)-(x_4,y_4),C:(x_5,y_5)-(x_6,y_6)</script><p>求 $a \to b \to c(a \in A,b \in B,c \in C)$ 的方案数。</p><p>其中 $a \to b$ 表示 $a$ 向下向右走到 $b$ 的路径。两个方案不同当且仅当 $a,b,c$ 不同，或 $a \to b,b \to c$ 不同。</p><p>$1 \le x_1 \le x_2 &lt; x_3 \le x_4 &lt; x_5 \le x_6 \le 10^6,1 \le y_1 \le y_2 &lt; y_3​ \le y_4 &lt; y_5 \le y_6 \le 10^6$。</p></blockquote><p>考虑枚举中间节点 $b$，需要计算的是一个点到一个矩形的方案数。将矩形差分，只需要计算点 $(0,0)$ 到矩形 $(0,0)-(x,y)$ 的方案数。</p><script type="math/tex; mode=display">\begin{aligned}\sum_{i=0}^{x} \sum_{j=0}^{y} \binom{i+j}{i} &= \sum_{i=0}^{x} \binom{y+i+1}{i+1} \\&= \sum_{i=-1}^{x} \binom{y+i+1}{y} - \binom{y}{y} \\&= \binom{x+y+2}{y+1} - 1\end{aligned}</script><p>差分的四项求和之后 $-1$ 就被消去了，而 $\binom{x+y+2}{y+1}$ 恰为 $(0,0) \to (x+1,y+1)$ 的方案数。记 $a \to b$ 表示 $a$ 到 $b$ 路径的方案数，那么 $b$ 到 $A$ 的方案数为</p><script type="math/tex; mode=display">b \to (x_1-1,y_1-1) + b \to (x_2,y_2) - b \to (x_1-1,y_2) - b \to (x_2,y_1-1)</script><p>$b$ 到 $C$ 的方案数类似，得到了 $O(n^2)$ 的做法。</p><p>通过差分相当于将 $A,B$ 分别转化为 $4$ 个点，而枚举 $4 \times 4$ 个点对是可以接受的，考虑枚举起点 $a$ 和终点 $c$，此时对答案贡献的系数为两个点对应系数的乘积。</p><p>一条 $a \to c$ 的路径产生的方案数为路径与 $B$ 的交点个数（每个交点都可以充当 $b$）。可以枚举路径进入和离开 $B$ 的点计算方案数，但这样仍是 $O(n^2)$ 的。若矩形包含 $a$ 那就不用枚举进入的点了。继续差分，将 $B$ 差分为四个以 $a$ 为左上角的矩形。枚举路径离开矩形的点计算方案数即可。</p><p>时间复杂度 $O(n)$，带一个比较大的常数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ar(x) array<span class="string">&lt;int,x&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e6</span><span class="number">+100</span>,MOD=<span class="number">1e9</span><span class="number">+7</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">qm</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y=MOD<span class="number">-2</span>)</span></span>&#123; <span class="type">int</span> res=<span class="number">1</span>; <span class="keyword">for</span>(;y;y&gt;&gt;=<span class="number">1</span>,x=<span class="number">1ll</span>*x*x%MOD) <span class="keyword">if</span>(y&amp;<span class="number">1</span>) res=<span class="number">1ll</span>*res*x%MOD; <span class="keyword">return</span> res; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">mod</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123; <span class="keyword">if</span>(x&gt;=MOD) x-=MOD; <span class="keyword">if</span>(x&lt;<span class="number">0</span>) x+=MOD; &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> gc getchar()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rd read()</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,f=<span class="number">0</span>; <span class="type">char</span> c=gc;</span><br><span class="line">    <span class="keyword">for</span>(;c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>;c=gc) f|=(c==<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span>(;c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>;c=gc) x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(c^<span class="number">48</span>);</span><br><span class="line">    <span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> jc[N],fjc[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    jc[<span class="number">0</span>]=<span class="number">1</span>; <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i) jc[i]=<span class="number">1ll</span>*jc[i<span class="number">-1</span>]*i%MOD;</span><br><span class="line">    fjc[n]=<span class="built_in">qm</span>(jc[n]); <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;~i;--i) fjc[i]=<span class="number">1ll</span>*fjc[i<span class="number">+1</span>]*(i<span class="number">+1</span>)%MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">CM</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span>&#123; <span class="keyword">return</span> n&lt;<span class="number">0</span>||m&lt;<span class="number">0</span>||m&gt;n?<span class="number">0</span>:<span class="number">1ll</span>*jc[n]*fjc[m]%MOD*fjc[n-m]%MOD; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> x_1,<span class="type">int</span> y_1,<span class="type">int</span> x_2,<span class="type">int</span> y_2)</span></span>&#123; <span class="keyword">return</span> <span class="built_in">CM</span>(<span class="built_in">abs</span>(x_2-x_1)+<span class="built_in">abs</span>(y_2-y_1),<span class="built_in">abs</span>(x_2-x_1)); &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x[<span class="number">7</span>],y[<span class="number">7</span>],ans=<span class="number">0</span>;</span><br><span class="line">vector&lt;ar(3)&gt; A,B,C;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">(ar(<span class="number">3</span>) a,ar(<span class="number">3</span>) b,ar(<span class="number">3</span>) c)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=a[<span class="number">1</span>];i&lt;=b[<span class="number">1</span>];++i) <span class="built_in">mod</span>(res+=<span class="number">1ll</span>*<span class="built_in">calc</span>(b[<span class="number">0</span>],i,a[<span class="number">0</span>],a[<span class="number">1</span>])*<span class="built_in">calc</span>(b[<span class="number">0</span>]<span class="number">+1</span>,i,c[<span class="number">0</span>],c[<span class="number">1</span>])%MOD*(b[<span class="number">0</span>]-a[<span class="number">0</span>]+i-a[<span class="number">1</span>]<span class="number">+1</span>)%MOD);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=a[<span class="number">0</span>];i&lt;=b[<span class="number">0</span>];++i) <span class="built_in">mod</span>(res+=<span class="number">1ll</span>*<span class="built_in">calc</span>(i,b[<span class="number">1</span>],a[<span class="number">0</span>],a[<span class="number">1</span>])*<span class="built_in">calc</span>(i,b[<span class="number">1</span>]<span class="number">+1</span>,c[<span class="number">0</span>],c[<span class="number">1</span>])%MOD*(i-a[<span class="number">0</span>]+b[<span class="number">1</span>]-a[<span class="number">1</span>]<span class="number">+1</span>)%MOD);</span><br><span class="line">    <span class="built_in">mod</span>(ans+=a[<span class="number">2</span>]*b[<span class="number">2</span>]*c[<span class="number">2</span>]*res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">init</span>(N<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">6</span>;++i) x[i]=rd;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">6</span>;++i) y[i]=rd;</span><br><span class="line"></span><br><span class="line">    A.<span class="built_in">pb</span>(&#123;x[<span class="number">2</span>],y[<span class="number">2</span>],<span class="number">1</span>&#125;),A.<span class="built_in">pb</span>(&#123;x[<span class="number">1</span>]<span class="number">-1</span>,y[<span class="number">1</span>]<span class="number">-1</span>,<span class="number">1</span>&#125;),A.<span class="built_in">pb</span>(&#123;x[<span class="number">2</span>],y[<span class="number">1</span>]<span class="number">-1</span>,<span class="number">-1</span>&#125;),A.<span class="built_in">pb</span>(&#123;x[<span class="number">1</span>]<span class="number">-1</span>,y[<span class="number">2</span>],<span class="number">-1</span>&#125;);</span><br><span class="line">    B.<span class="built_in">pb</span>(&#123;x[<span class="number">4</span>],y[<span class="number">4</span>],<span class="number">1</span>&#125;),B.<span class="built_in">pb</span>(&#123;x[<span class="number">3</span>]<span class="number">-1</span>,y[<span class="number">3</span>]<span class="number">-1</span>,<span class="number">1</span>&#125;),B.<span class="built_in">pb</span>(&#123;x[<span class="number">4</span>],y[<span class="number">3</span>]<span class="number">-1</span>,<span class="number">-1</span>&#125;),B.<span class="built_in">pb</span>(&#123;x[<span class="number">3</span>]<span class="number">-1</span>,y[<span class="number">4</span>],<span class="number">-1</span>&#125;);</span><br><span class="line">    C.<span class="built_in">pb</span>(&#123;x[<span class="number">6</span>]<span class="number">+1</span>,y[<span class="number">6</span>]<span class="number">+1</span>,<span class="number">1</span>&#125;),C.<span class="built_in">pb</span>(&#123;x[<span class="number">5</span>],y[<span class="number">5</span>],<span class="number">1</span>&#125;),C.<span class="built_in">pb</span>(&#123;x[<span class="number">6</span>]<span class="number">+1</span>,y[<span class="number">5</span>],<span class="number">-1</span>&#125;),C.<span class="built_in">pb</span>(&#123;x[<span class="number">5</span>],y[<span class="number">6</span>]<span class="number">+1</span>,<span class="number">-1</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> a:A) <span class="keyword">for</span>(<span class="keyword">auto</span> b:B) <span class="keyword">for</span>(<span class="keyword">auto</span> c:C) <span class="built_in">sol</span>(a,b,c);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> solutions </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>常用组合恒等式</title>
      <link href="/notes/%E5%B8%B8%E7%94%A8%E7%BB%84%E5%90%88%E6%81%92%E7%AD%89%E5%BC%8F/"/>
      <url>/notes/%E5%B8%B8%E7%94%A8%E7%BB%84%E5%90%88%E6%81%92%E7%AD%89%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>限制条件在 OI 中基本用不到，就不写了。</p><script type="math/tex; mode=display">\begin{align}& \binom{n}{m} = \frac{n!}{m!(n-m)!} \\& \binom{n}{m} = \binom{n}{n-m} \\& \binom{n}{m} = \frac{n}{m} \binom{n-1}{m-1} \\& \binom{n}{m} = \binom{n-1}{m} + \binom{n-1}{m-1} \\& \binom{n}{m} = (-1)^{m} \binom{m-n-1}{m} \\& \binom{a}{b}\binom{b}{c} = \binom{a}{c}\binom{a-c}{b-c} \\& (a+b)^{n} = \sum_{i=0}^{n} \binom{n}{i} a^ib^{n-i} \\& \sum_{i=0}^{n} \binom{i}{m} = \binom{n+1}{m+1} \\& \sum_{i} \binom{a}{i} \binom{b}{n-i} = \binom{a+b}{n} \\& \sum_{\sum i_j = n} \prod \binom{a_i}{i_j} = \binom{\sum a_i}{n}\end{align}</script>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>P3214 [HNOI2011] 卡农</title>
      <link href="/solutions/P3214/"/>
      <url>/solutions/P3214/</url>
      
        <content type="html"><![CDATA[<blockquote><p>从 $[1,2^n)$ 中选择 $m$ 个互不相同且异或和为 $0$ 的数，求方案数。</p><p>$1 \le n,m \le 10^6$。</p></blockquote><p>考虑 DP，记 $f_i$ 为选择 $i$ 个数的方案数。先考虑顺序，这样选择的数不会有顺序的限制，最后再除 m! 得到答案。</p><p>发现确定前 $i-1$ 个数就可以通过异或和为 $0$ 的条件得到第 $i$ 个数，那么得到初始方案数 $\binom{2^n-1}{i-1}(i-1)!$。记前 $i-1$ 个数的异或和为 $u$，那么 $i$ 填 $u$。考虑不合法的方案，减去 $u=0$ 和 $u$ 出现两次的方案，剩下的都合法。得到转移式</p><script type="math/tex; mode=display">f_i = \binom{2^n-1}{i-1}(i-1)! - f_{i-1} - (i-1)(2^n-1-(i-2))f_{i-2}</script><p>初值 $f_1=f_2=0$。时间复杂度 $O(m)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span><span class="number">+10</span>,MOD=<span class="number">1e8</span><span class="number">+7</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">qm</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y=MOD<span class="number">-2</span>)</span></span>&#123; <span class="type">int</span> res=<span class="number">1</span>; <span class="keyword">for</span>(;y;y&gt;&gt;=<span class="number">1</span>,x=<span class="number">1ll</span>*x*x%MOD) <span class="keyword">if</span>(y&amp;<span class="number">1</span>) res=<span class="number">1ll</span>*res*x%MOD; <span class="keyword">return</span> res; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">mod</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123; <span class="keyword">if</span>(x&gt;=MOD) x-=MOD; <span class="keyword">if</span>(x&lt;<span class="number">0</span>) x+=MOD; &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> gc getchar()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rd read()</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> x=<span class="number">0</span>,f=<span class="number">0</span>; <span class="type">char</span> c=gc;</span><br><span class="line"><span class="keyword">for</span>(;c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>;c=gc) f|=(c==<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span>(;c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>;c=gc) x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(c^<span class="number">48</span>);</span><br><span class="line"><span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> jc[N],fjc[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">jc[<span class="number">0</span>]=<span class="number">1</span>; <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i) jc[i]=<span class="number">1ll</span>*jc[i<span class="number">-1</span>]*i%MOD;</span><br><span class="line">fjc[n]=<span class="built_in">qm</span>(jc[n]); <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;~i;--i) fjc[i]=<span class="number">1ll</span>*fjc[i<span class="number">+1</span>]*(i<span class="number">+1</span>)%MOD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,pw,A[N],f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">n=rd,m=rd,pw=<span class="built_in">qm</span>(<span class="number">2</span>,n),<span class="built_in">init</span>(m);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=A[<span class="number">0</span>]=<span class="number">1</span>;i&lt;=m;++i) A[i]=<span class="number">1ll</span>*A[i<span class="number">-1</span>]*(pw-i)%MOD;</span><br><span class="line"></span><br><span class="line">f[<span class="number">1</span>]=f[<span class="number">2</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>;i&lt;=m;++i)&#123;</span><br><span class="line"><span class="built_in">mod</span>(f[i]=A[i<span class="number">-1</span>]-f[i<span class="number">-1</span>]);</span><br><span class="line"><span class="built_in">mod</span>(f[i]-=<span class="number">1ll</span>*(pw<span class="number">-1</span>-(i<span class="number">-2</span>))*(i<span class="number">-1</span>)%MOD*f[i<span class="number">-2</span>]%MOD);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="number">1ll</span>*f[m]*fjc[m]%MOD);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> solutions </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>P8907 [USACO22DEC] Making Friends P</title>
      <link href="/solutions/P8907/"/>
      <url>/solutions/P8907/</url>
      
        <content type="html"><![CDATA[<blockquote><p>$n$ 个点 $m$ 条边的无向图，按编号从小到大依次删点，每次删点后将其邻点补成完全图，求新增边数。</p><p>$1 \le n,m \le 2 \times 10^5$。</p></blockquote><p>最后 $(i,j)(i &lt; j)$ 有连边当前仅当原图存在 $i \to j$ 的路径使得路径上点（除 $j$ 外）的编号均 $\le i$。</p><p>考虑枚举 $i$ 统计上述点对的数量，最后减去 $m$ 即为答案。                             </p><p>按编号从小到大枚举 $i$，枚举过的点标 $1$，未枚举的标 $0$。那么 $j$ 的数量即为 $i$ 所在的 $1$ 连通块相邻的 $0$ 点的数量。</p><p>用并查集维护连通块，用 <code>set</code> 记录相邻的 $0$ 点。当枚举到 $i$ 时，先将相邻的 $0$ 点加入对应的 <code>set</code>，再与相邻的 $1$ 点合并，$j$ 的数量即为对应 <code>set</code> 的大小。启发式合并，时间复杂度 $O(n\log^2n)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> U(x) ((int)x.size())</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span><span class="number">+100</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> gc getchar()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rd read()</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> x=<span class="number">0</span>,f=<span class="number">0</span>; <span class="type">char</span> c=gc;</span><br><span class="line"><span class="keyword">for</span>(;c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>;c=gc) f|=(c==<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span>(;c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>;c=gc) x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(c^<span class="number">48</span>);</span><br><span class="line"><span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m; ll ans=<span class="number">0</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; G[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fa[N],siz[N]; set&lt;<span class="type">int</span>&gt; s[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123; <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i) fa[i]=i,siz[i]=<span class="number">1</span>; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123; <span class="keyword">return</span> fa[x]==x?x:fa[x]=<span class="built_in">find</span>(fa[x]); &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mer</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">x=<span class="built_in">find</span>(x),y=<span class="built_in">find</span>(y); <span class="keyword">if</span>(x==y) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span>(siz[x]&lt;siz[y]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">fa[y]=x,siz[x]+=siz[y]; <span class="keyword">for</span>(<span class="keyword">auto</span> v:s[y]) s[x].<span class="built_in">insert</span>(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">n=rd,m=rd,<span class="built_in">init</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,x,y;i&lt;=m;++i) G[x=rd].<span class="built_in">pb</span>(y=rd),G[y].<span class="built_in">pb</span>(x);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> u=<span class="number">1</span>;u&lt;=n;++u)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> v:G[u]) <span class="keyword">if</span>(v&gt;u) s[u].<span class="built_in">insert</span>(v);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> v:G[u]) <span class="keyword">if</span>(v&lt;u) <span class="built_in">mer</span>(v,u);</span><br><span class="line"><span class="keyword">if</span>(s[<span class="built_in">find</span>(u)].<span class="built_in">count</span>(u)) s[<span class="built_in">find</span>(u)].<span class="built_in">erase</span>(u); <span class="comment">//此时 u 不是 0 点，如果有要删去。</span></span><br><span class="line">ans+=<span class="built_in">U</span>(s[<span class="built_in">find</span>(u)]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans-m);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> solutions </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>QOJ171 Longest Shortest Path</title>
      <link href="/solutions/QOJ171/"/>
      <url>/solutions/QOJ171/</url>
      
        <content type="html"><![CDATA[<p>将最短路写成线性规划形式。</p><script type="math/tex; mode=display">\begin{align}\max \quad & p_t-p_s \\ \texttt{s.t.} \quad& p_v-p_u \le d_e+x_e \\& \sum_{e} c_ex_e \le P \\& x_e,p_u \ge 0 \end{align}</script><p>线性规划对偶，记 $out_u,in_u$ 分别为 $u$ 的出、入边集合。那么等价于</p><script type="math/tex; mode=display">\begin{align}\min \quad & \sum_{e} d_ef_e + PF \\\texttt{s.t.} \quad& \sum_{e \in in_s} f_e - \sum_{e \in out_s} f_e \ge -1 \\& \sum_{e \in in_t} f_e - \sum_{e \in out_t} f_e \ge 1 \\& \sum_{e \in in_u} f_e - \sum_{e \in out_u} f_e \ge 0 \quad u \in V \setminus \{s,t\} \\& c_eF - f_e \ge 0 \\& F,f_e \ge 0\end{align}</script><p>由于要取 $\min$ ，所以前三个约束取等号更优，发现是网络流的限制，即</p><script type="math/tex; mode=display">\begin{align}\min \quad & \sum_{e} d_ef_e + PF \\\texttt{s.t.} \quad& f 为 s 到 t 流量为 1 的流 \\& c_eF - f_e \ge 0 \\& F,f_e \ge 0\end{align}</script><p>要将 $c_eF - f_e \ge 0$ 转化为流量的限制，令 $f’_e = \frac{f_e}{F}$，则</p><script type="math/tex; mode=display">\begin{align}\min \quad & (\sum_{e} d_ef'_e + P)F \\\texttt{s.t.} \quad& f' 为 s 到 t 流量为 \frac{1}{F} 的流 \\& f'_e \le c_e \\& F > 0,f'_e \ge 0\end{align}</script><p>这是费用流的形式，$\sum_e d_ef’_e + P$ 关于 $\frac{1}{F}$ 是凸的，那么 $(\sum_{e} d_ef’_e + P)F$ 的最小值在凸包的端点处取到，用 EK 求解费用流，每次增广后更新答案即可。记 $F$ 为 $c$ 的上界，时间复杂度 $O(Fnm^2)$，实际上远远跑不满。</p><p>还可以用拉格朗日对偶，<a href="/notes/拉格朗日乘数及其对偶">详见</a>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> db=<span class="type">double</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">200</span><span class="number">+10</span>,M=<span class="number">2e3</span><span class="number">+10</span>,INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">chkmin</span><span class="params">(<span class="type">int</span> &amp;x,<span class="type">int</span> y)</span></span>&#123; <span class="keyword">return</span> y&lt;x?x=y,<span class="number">1</span>:<span class="number">0</span>; &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> gc getchar()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rd read()</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> x=<span class="number">0</span>,f=<span class="number">0</span>; <span class="type">char</span> c=gc;</span><br><span class="line"><span class="keyword">for</span>(;c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>;c=gc) f|=(c==<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span>(;c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>;c=gc) x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(c^<span class="number">48</span>);</span><br><span class="line"><span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,s,t,P,maxflow=<span class="number">0</span>,mincost=<span class="number">0</span>; db ans=INF;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> head[N],ne[M*<span class="number">2</span>],v[M*<span class="number">2</span>],fl[M*<span class="number">2</span>],w[M*<span class="number">2</span>],tot=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> f,<span class="type">int</span> z)</span></span>&#123;</span><br><span class="line">ne[++tot]=head[x],head[x]=tot,v[tot]=y,fl[tot]=f,w[tot]=z;</span><br><span class="line">ne[++tot]=head[y],head[y]=tot,v[tot]=x,fl[tot]=<span class="number">0</span>,w[tot]=-z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dis[N],vis[N],pre[N],idx[N]; queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">spfa</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i) dis[i]=INF,vis[i]=<span class="number">0</span>; q.<span class="built_in">push</span>(s),dis[s]=<span class="number">0</span>,vis[s]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line"><span class="type">int</span> u=q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>(),vis[u]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=ne[i])</span><br><span class="line"><span class="keyword">if</span>(fl[i]&amp;&amp;<span class="built_in">chkmin</span>(dis[v[i]],dis[u]+w[i]))</span><br><span class="line">pre[v[i]]=u,idx[v[i]]=i,q.<span class="built_in">push</span>(v[i]),vis[v[i]]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dis[t]!=INF;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">n=rd,m=rd,P=rd,s=rd,t=rd;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,x,y,z,f;i&lt;=m;++i) x=rd,y=rd,z=rd,f=rd,<span class="built_in">add</span>(x,y,f,z);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">spfa</span>())&#123;</span><br><span class="line"><span class="type">int</span> dflow=INF; <span class="keyword">for</span>(<span class="type">int</span> i=t;i!=s;i=pre[i]) dflow=<span class="built_in">min</span>(dflow,fl[idx[i]]);</span><br><span class="line">maxflow+=dflow,mincost+=dis[t]*dflow;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=t;i!=s;i=pre[i]) fl[idx[i]]-=dflow,fl[idx[i]^<span class="number">1</span>]+=dflow;</span><br><span class="line">ans=<span class="built_in">min</span>(ans,(db)(P+mincost)/maxflow);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.6lf\n&quot;</span>, ans);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> solutions </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>拉格朗日乘数及其对偶</title>
      <link href="/notes/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E4%B9%98%E6%95%B0%E5%8F%8A%E5%85%B6%E5%AF%B9%E5%81%B6/"/>
      <url>/notes/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E4%B9%98%E6%95%B0%E5%8F%8A%E5%85%B6%E5%AF%B9%E5%81%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>求多元函数 $f(x)$ 在满足 $g_i(x)=0$ 的极值。设一个乘数 $\lambda$，求下面多元函数的极值</p><script type="math/tex; mode=display">f(x,\lambda)=f(x)+\sum_{i} \lambda_ig_i(x)</script><blockquote><p><strong>例</strong> 求 $y=\frac{1}{x}$ 到原点最近的点。</p><p>即在满足 $g(x,y)=xy-1=0$ 的条件下，最小化 $f(x,y)=x^2+y^2$。</p><p>设乘数 $\lambda$，最小化 $f(x,y,\lambda)=f(x,y)+\lambda g(x,y)=x^2+y^2+\lambda xy-\lambda$。</p><p>分别对 $x,y,\lambda$ 求导，令导数为 $0$，得到</p><script type="math/tex; mode=display">\left \{\begin{matrix}2x+\lambda y = 0 \\2y+\lambda x = 0 \\xy-1 = 0\end{matrix}\right.</script><p>解得</p><script type="math/tex; mode=display">\left \{\begin{matrix}x = 1 \\y = 1 \\\lambda = -2\end{matrix}\right.或\\left \{\begin{matrix}x = -1 \\y = -1 \\\lambda = -2\end{matrix}\right.</script></blockquote><p>线性规划对偶可以得到方便的机械化方法。不会证明，下面只讲方法。</p><ul><li><p>将线性约束转化为 $… \le 0$ 的形式。</p></li><li><p>对每个约束设一个乘数 $\lambda$，若求 $\min$ 那么限制 $\lambda \ge 0$，否则限制 $\lambda \le 0$。</p></li><li><p>将约束乘乘数写入最优化函数，即求 $L(x,\lambda)$ 的最值。将 $L(x,\lambda)$ 转化为以 $x$ 为主元的形式，通过限制系数使得 $L(x,\lambda)$ 不会取到 $\infty/-\infty$。</p></li><li><p>将 $\min/\max$ 取反，将带 $x$ 的项删去得到新的最优化函数。</p></li></ul><blockquote><p><strong>例</strong> <a href="https://www.luogu.com.cn/problem/AT_icpc2015autumn_j">Longest Shortest Path</a></p><p>需要将下式对偶</p><script type="math/tex; mode=display">\begin{align}\max \quad & p_t-p_s \\ \texttt{s.t.} \quad& p_v-p_u \le d_e+x_e \\& \sum_{e} c_ex_e \le P \\& x_e,p_u \ge 0 \end{align}</script><p>改写为</p><script type="math/tex; mode=display">\begin{align}\max \quad & p_t-p_s \\ \texttt{s.t.} \quad& p_v-p_u-x_e-d_e \le 0 \\& \sum_{e} c_ex_e-P \le 0 \\& x_e,p_u \ge 0 \end{align}</script><p>设乘数 $f_e,F$ 得到</p><script type="math/tex; mode=display">(\sum_{e \in in_s} f_e - \sum_{e \in out_s} f_e - 1) p_s \\ + (\sum_{e \in in_s} f_e - \sum_{e \in out_s} f_e + 1) p_t \\ + \sum_{u \in V \setminus \{s,t\}} (\sum_{e \in in_s} f_e - \sum_{e \in out_s}) p_u \\ + \sum_{e} (c_eF-f_e)x_e - \sum_{e} f_ed_e - FP</script><p>为防止取到 $\infty$，将系数限制为 $\le 0$，得到对偶</p><script type="math/tex; mode=display">\begin{align}\min \quad & \sum_{e} -d_ef_e - PF \\\texttt{s.t.} \quad& \sum_{e \in in_s} f_e - \sum_{e \in out_s} f_e \le 1 \\& \sum_{e \in in_t} f_e - \sum_{e \in out_t} f_e \le -1 \\& \sum_{e \in in_u} f_e - \sum_{e \in out_u} f_e \le 0 \quad u \in V \setminus \{s,t\} \\& c_eF - f_e \le 0 \\& F,f_e \le 0\end{align}</script><p>将 $f_e,F$ 取反得到</p><script type="math/tex; mode=display">\begin{align}\min \quad & \sum_{e} d_ef_e + PF \\\texttt{s.t.} \quad& \sum_{e \in in_s} f_e - \sum_{e \in out_s} f_e \ge -1 \\& \sum_{e \in in_t} f_e - \sum_{e \in out_t} f_e \ge 1 \\& \sum_{e \in in_u} f_e - \sum_{e \in out_u} f_e \ge 0 \quad u \in V \setminus \{s,t\} \\& c_eF - f_e \ge 0 \\& F,f_e \ge 0\end{align}</script></blockquote><p>对于一般的拉格朗日对偶，最优化函数满足凸优化和 slater 条件是强对偶的充分条件。</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h4 id="1-NOI2012-骑行川藏"><a href="#1-NOI2012-骑行川藏" class="headerlink" title="1.[NOI2012] 骑行川藏"></a><a href="https://www.luogu.com.cn/problem/P2179">1.[NOI2012] 骑行川藏</a></h4><script type="math/tex; mode=display">\begin{align}\min \quad & \sum_{i} \frac{s_i}{v_i} \\\texttt{s.t.} \quad& \sum_{i} s_ik_i(v_i-v'_i)^2 \le E \\& v_i \ge v'_i \\& v_i > 0\end{align}</script><p>贪心，令 $\sum_{i} s_ik_i(v_i-v’_i)^2=E$ 即可。</p><p>用拉格朗日乘数法，得到</p><script type="math/tex; mode=display">\begin{align}2 \lambda k_iv_i^2(v_i-v'_i) &= 1 \tag{1} \\\sum_{i} s_ik_i(v_i-v'_i)^2 &= E \tag{2}\end{align}</script><p>对于给定的 $\lambda$，通过 $(1)$ 式计算 $v_i$ 并带入 $(2)$ 式判断即可。发现 $\lambda$ 递增时 $v_i$ 递减，二分 $\lambda$ 即可。时间复杂度 $O(n\log^2V)$。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.luogu.com.cn/article/4xdbun0b">[OI笔记]利用拉格朗日乘数法求函数的最值</a></p><p><a href="https://www.cnblogs.com/yyyyxh/p/17939643/LPdual">在 OI 中更易上手的线性规划对偶</a></p>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>长链剖分</title>
      <link href="/notes/%E9%95%BF%E9%93%BE%E5%89%96%E5%88%86/"/>
      <url>/notes/%E9%95%BF%E9%93%BE%E5%89%96%E5%88%86/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>以子树中最大深度最大的儿子为重儿子。</p><ul><li><p>链的长度和为 $n$。</p></li><li><p>若链 $L_1$ 向上跳到 $L_2$，那么 $L_2 \ge L_1+1$。</p></li><li><p>点到根节点路径上有 $O(\sqrt{n})$ 条链。</p></li></ul><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h4 id="1-【模板】树上-K-级祖先"><a href="#1-【模板】树上-K-级祖先" class="headerlink" title="1.【模板】树上 K 级祖先"></a><a href="https://www.luogu.com.cn/problem/P5903">1.【模板】树上 K 级祖先</a></h4><p>$k$ 级祖先所在链的长度 $\ge k+1$。考虑找到 $k’ \ge \frac{k}{2}$ 级祖先 $x$，那么 $k$ 级祖先到 $x$ 的距离不超过 $x$ 所在链长。</p><p>对每个链头维护所在链的集合和向上跳不超过链长的集合。取 $k’$ 为 $k$ 的二进制最高位。时间复杂度 $O(n\log n)-O(1)$。</p><p><a href="https://www.luogu.com.cn/paste/7rdq0fum">code</a></p><h4 id="2-Dominant-Indices"><a href="#2-Dominant-Indices" class="headerlink" title="2.Dominant Indices"></a><a href="https://www.luogu.com.cn/problem/CF1009F">2.Dominant Indices</a></h4><p>实现时用指针，时空复杂度均为 $O(n)$。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span> </span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">100</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> gc getchar()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rd read()</span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">int</span> x=<span class="number">0</span>,f=<span class="number">0</span>; <span class="type">char</span> c=gc;</span><br><span class="line"><span class="keyword">for</span>(;c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>;c=gc) f|=(c==<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span>(;c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>;c=gc) x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(c^<span class="number">48</span>);</span><br><span class="line"><span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,ans[N],*f[N],tmp[N],*cur=tmp+<span class="number">1</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; G[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dep[N],mx[N],son[N];</span><br><span class="line"><span class="type">void</span> <span class="title function_">dfs0</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fu)</span>&#123;</span><br><span class="line">mx[u]=dep[u]=dep[fu]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> v:G[u])&#123;</span><br><span class="line"><span class="keyword">if</span>(v==fu) <span class="keyword">continue</span>;</span><br><span class="line">dfs0(v,u),mx[u]=max(mx[u],mx[v]);</span><br><span class="line"><span class="keyword">if</span>(mx[v]&gt;mx[son[u]]) son[u]=v;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">assign</span><span class="params">(<span class="type">int</span> u)</span>&#123; f[u]=cur,cur+=mx[u]-dep[u]+<span class="number">1</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">dfs1</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fu)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(son[u]) f[son[u]]=f[u]+<span class="number">1</span>,dfs1(son[u],u),ans[u]=ans[son[u]]+<span class="number">1</span>;</span><br><span class="line">f[u][<span class="number">0</span>]=<span class="number">1</span>; <span class="keyword">if</span>(f[u][<span class="number">0</span>]&gt;=f[u][ans[u]]) ans[u]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> v:G[u])&#123;</span><br><span class="line"><span class="keyword">if</span>(v==fu||v==son[u]) <span class="keyword">continue</span>; assign(v),dfs1(v,u);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=mx[v]-dep[v];++i)&#123;</span><br><span class="line">f[u][i+<span class="number">1</span>]+=f[v][i];</span><br><span class="line"><span class="keyword">if</span>(f[u][i+<span class="number">1</span>]&gt;f[u][ans[u]]||(f[u][i+<span class="number">1</span>]==f[u][ans[u]]&amp;&amp;i+<span class="number">1</span>&lt;ans[u])) ans[u]=i+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">n=rd; <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,x,y;i&lt;n;i++) G[x=rd].pb(y=rd),G[y].pb(x);</span><br><span class="line"></span><br><span class="line">dfs0(<span class="number">1</span>,<span class="number">0</span>),assign(<span class="number">1</span>),dfs1(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans[i]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-WC2010-重建计划"><a href="#3-WC2010-重建计划" class="headerlink" title="3.[WC2010] 重建计划"></a><a href="https://www.luogu.com.cn/problem/P4292">3.[WC2010] 重建计划</a></h4><p>二分，长链剖分优化 DP，合并需要查询区间长度，用线段树维护即可，时间复杂度 $O(n\log^2n)$。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.luogu.com.cn/article/522npqp1">长链剖分</a></p>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SAM</title>
      <link href="/notes/SAM/"/>
      <url>/notes/SAM/</url>
      
        <content type="html"><![CDATA[<p>艹，我都第几次学了。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>增量法构造。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TREE</span>&#123; <span class="type">int</span> ne[SZ],fa,len,siz; &#125;t[N&lt;&lt;<span class="number">1</span>]; <span class="type">int</span> las=<span class="number">1</span>,tot=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ins</span><span class="params">(<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> p=las,np=++tot,v,nv; las=np,t[np].len=t[p].len<span class="number">+1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;p&amp;&amp;!t[p].ne[c];p=t[p].fa) t[p].ne[c]=np;</span><br><span class="line">    <span class="keyword">if</span>(!p) <span class="keyword">return</span> t[np].fa=<span class="number">1</span>,<span class="built_in">void</span>(); v=t[p].ne[c];</span><br><span class="line">    <span class="keyword">if</span>(t[v].len==t[p].len<span class="number">+1</span>) <span class="keyword">return</span> t[np].fa=v,<span class="built_in">void</span>();</span><br><span class="line">    t[nv=++tot]=t[v],t[nv].len=t[p].len<span class="number">+1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;p&amp;&amp;t[p].ne[c]==v;p=t[p].fa) t[p].ne[c]=nv;</span><br><span class="line">    t[v].fa=t[np].fa=nv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="普通后缀自动机"><a href="#普通后缀自动机" class="headerlink" title="普通后缀自动机"></a>普通后缀自动机</h2><h4 id="1-【模板】后缀自动机（SAM）"><a href="#1-【模板】后缀自动机（SAM）" class="headerlink" title="1.【模板】后缀自动机（SAM）"></a><a href="https://www.luogu.com.cn/problem/P3804">1.【模板】后缀自动机（SAM）</a></h4><p>后缀自动机节点的 endpos 集合大小即为当前节点字符串的出现次数。</p><h4 id="2-不同子串个数"><a href="#2-不同子串个数" class="headerlink" title="2.不同子串个数"></a><a href="https://www.luogu.com.cn/problem/P2408">2.不同子串个数</a></h4><ul><li><p>法一 DAG 上 DP</p><p>性质：任意两个节点的表示集合没有交。</p><p>记 $f_u$ 为从 $u$ 出发的路径条数即可。</p></li><li><p>法二 统计树上每个节点的字符串个数即可。</p></li></ul><h4 id="3-SDOI2016-生成魔咒-洛谷"><a href="#3-SDOI2016-生成魔咒-洛谷" class="headerlink" title="3.[SDOI2016] 生成魔咒 - 洛谷"></a><a href="https://www.luogu.com.cn/problem/P4070">3.[SDOI2016] 生成魔咒 - 洛谷</a></h4><h4 id="4-TJOI2015-弦论-洛谷"><a href="#4-TJOI2015-弦论-洛谷" class="headerlink" title="4.[TJOI2015] 弦论 - 洛谷"></a><a href="https://www.luogu.com.cn/problem/P3975">4.[TJOI2015] 弦论 - 洛谷</a></h4><h2 id="后缀自动机和-AC-自动机"><a href="#后缀自动机和-AC-自动机" class="headerlink" title="后缀自动机和 AC 自动机"></a>后缀自动机和 AC 自动机</h2><p>parent 树可以看成对所有子串建立 AC 自动机。</p><h4 id="1-LCS-Longest-Common-Substring"><a href="#1-LCS-Longest-Common-Substring" class="headerlink" title="1.LCS - Longest Common Substring"></a><a href="https://www.luogu.com.cn/problem/SP1811">1.LCS - Longest Common Substring</a></h4><h4 id="2-Cyclical-Quest"><a href="#2-Cyclical-Quest" class="headerlink" title="2.Cyclical Quest"></a><a href="https://www.luogu.com.cn/problem/CF235C">2.Cyclical Quest</a></h4><h4 id="3-BJOI2020-封印"><a href="#3-BJOI2020-封印" class="headerlink" title="3.[BJOI2020] 封印"></a><a href="https://www.luogu.com.cn/problem/P6640">3.[BJOI2020] 封印</a></h4><h2 id="后缀自动机和后缀树"><a href="#后缀自动机和后缀树" class="headerlink" title="后缀自动机和后缀树"></a>后缀自动机和后缀树</h2><p>反串的 parent 树就是后缀树。</p><h4 id="1-AHOI2013-差异"><a href="#1-AHOI2013-差异" class="headerlink" title="1.[AHOI2013] 差异"></a><a href="https://www.luogu.com.cn/problem/P4248">1.[AHOI2013] 差异</a></h4><h4 id="2-十二省联考-2019-字符串问题"><a href="#2-十二省联考-2019-字符串问题" class="headerlink" title="2.[十二省联考 2019] 字符串问题"></a><a href="https://www.luogu.com.cn/problem/P5284">2.[十二省联考 2019] 字符串问题</a></h4><h2 id="广义后缀自动机"><a href="#广义后缀自动机" class="headerlink" title="广义后缀自动机"></a>广义后缀自动机</h2><p>就是后缀自动机插入多个字符串。</p><p>插入一个字符串后将 <code>lst</code> 设为 $1$，是常见的伪广义后缀自动机写法，但是时间复杂度是正确的。</p><h4 id="1-SNOI2020-字符串"><a href="#1-SNOI2020-字符串" class="headerlink" title="1.[SNOI2020] 字符串"></a><a href="https://www.luogu.com.cn/problem/P6793">1.[SNOI2020] 字符串</a></h4><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/alex-wei/p/Common_String_Theory_Theory_automaton_related.html">常见字符串算法 II：自动机相关</a></p><p><a href="https://www.luogu.com/article/w967d5rp">后缀自动机学习笔记(应用篇)</a></p>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>exKMP</title>
      <link href="/notes/exKMP/"/>
      <url>/notes/exKMP/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>对于字符串 $s$，记 $z_i$ 为 $i$ 后缀与 $s$ 的最长公共前缀。exKMP 算法可以 $O(n)$ 求 $z$。</p><p>记 $[i,i+z_i-1]$ 为匹配段，在求解过程中维护最靠右的匹配段 $[l,r]$，当求解 $z_i$ 时。</p><ul><li><p>$r &lt; i$ 暴力匹配。</p></li><li><p>$i \le r$ 令 $z_i=\min(r-i+1,z_{i-l+1})$，再暴力匹配。</p></li></ul><p>均摊线性。</p><p>$[1,z_1]$ 是没有意义的，不要计入 $[l,r]$。</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h4 id="1-【模板】扩展-KMP-exKMP（Z-函数）"><a href="#1-【模板】扩展-KMP-exKMP（Z-函数）" class="headerlink" title="1.【模板】扩展 KMP/exKMP（Z 函数）"></a><a href="https://www.luogu.com.cn/problem/P5410">1.【模板】扩展 KMP/exKMP（Z 函数）</a></h4><p>构造 $b+!+a$。需要特判 $z_1$。</p><h4 id="2-Prefixes-and-Suffixes"><a href="#2-Prefixes-and-Suffixes" class="headerlink" title="2.Prefixes and Suffixes"></a><a href="https://www.luogu.com.cn/problem/CF432D">2.Prefixes and Suffixes</a></h4><p>完美字串是好找的，需要计算每个前缀的出现次数，计算 $z$，每次 $[1,z_i]$ 区间加 $1$。时间复杂度 $O(n)$。</p><h4 id="3-Om-Nom-and-Necklace"><a href="#3-Om-Nom-and-Necklace" class="headerlink" title="3.Om Nom and Necklace"></a><a href="https://www.luogu.com.cn/problem/CF526D">3.Om Nom and Necklace</a></h4><p>相当于 $S=AA…AB$，$A$ 有 $k$ 个，$B$ 为 $A$ 的前缀。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/alex-wei/p/Basic_String_Theory.html">字符串基础</a></p>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ACAM</title>
      <link href="/notes/ACAM/"/>
      <url>/notes/ACAM/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>用于解决多模式串匹配问题。</p><p>将模式串插入 trie 中，对每个点构造 $fail$ 指向模式串中与其后缀匹配的最长前缀。</p><p>以每个点的 $fail$ 为父节点构建 fail 树，满足节点 $x$ 对应的串为节点 $y$ 对应的串的后缀当且仅当 $y \in T(x)$。</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h4 id="1-AC-自动机（简单版）"><a href="#1-AC-自动机（简单版）" class="headerlink" title="1.AC 自动机（简单版）"></a><a href="https://www.luogu.com.cn/problem/P3808">1.AC 自动机（简单版）</a></h4><p>出现过，遍历后就赋值为 $-1$，遇到 $-1$ 则停止，查询时间复杂度线性。</p><h4 id="2-【模板】AC-自动机"><a href="#2-【模板】AC-自动机" class="headerlink" title="2.【模板】AC 自动机"></a><a href="https://www.luogu.com.cn/problem/P5357">2.【模板】AC 自动机</a></h4><p>将文本串对应的所有节点标记，相当于查询子树和。</p><h4 id="3-HNOI2004-L-语言"><a href="#3-HNOI2004-L-语言" class="headerlink" title="3.[HNOI2004] L 语言"></a><a href="https://www.luogu.com.cn/problem/P2292">3.[HNOI2004] L 语言</a></h4><p>DP，记 $f_i$ 为 $i$ 前缀是否合法，转移形如 $f_i|=f_j([j+1,i] \in D)$，由于 $|s| \le 20$，对 trie 上每个节点维护二进制状态表示长为 $k$ 的模式串是否出现即可 $O(1)$ 转移。</p><h4 id="4-COCI2015-Divljak"><a href="#4-COCI2015-Divljak" class="headerlink" title="4.[COCI2015] Divljak"></a><a href="https://www.luogu.com.cn/problem/P5840">4.[COCI2015] Divljak</a></h4><p>将 $S$ 插入 trie 中，建立 ACAM。相当于单点加颜色，查询子树中颜色种类数。对每个点维护子树中颜色种类数，每次是链并的加，按 dfs 序排序后，容斥一下即可。可以再差分用树状数组维护。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/alex-wei/p/Common_String_Theory_Theory_automaton_related.html">常见字符串算法 II：自动机相关</a></p>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>万能欧几里得</title>
      <link href="/notes/%E4%B8%87%E8%83%BD%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/"/>
      <url>/notes/%E4%B8%87%E8%83%BD%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>以求 $\sum_{i=1}^{n} \left \lfloor \frac{ai+b}{c} \right \rfloor$ 为例。此和式相当于求线段 $y=\frac{a}{c}x+\frac{b}{c}(x \in [1,n])$ 下面横坐标为正整数的整点个数。</p><p>考虑构造一个字符串，从左到右遍历该线段，每当遇到 $y=k(k \in \mathbb{Z})$ 则加 $\texttt{U}$，遇到 $x=k(k \in \mathbb{Z})$ 则加 $\texttt{R}$。只需要知道该字符串即可得到和式的和。</p><p>记 $f(S)$ 为字符串 $S$ 对应和式的答案，那么原和式的答案为 $f(\left \lfloor \frac{b}{c} \right \rfloor \times U + S)$。需要用 $f(S_1),f(S_2)$ 计算 $f(S_1+S_2)$，这个需要依据和式。来推一下我们的例子</p><script type="math/tex; mode=display">\begin{align}f(S) &= f(S_1) \times f(S_2) \\&= f(S_1) + \sum_{i=1}^{n_2} (\left \lfloor \frac{ai+b}{c} \right \rfloor + cnt_1(U)) \\&= f(S_1)+f(S_2)+n_2 \times cnt_1(U)\end{align}</script><p>用函数 $f$ 储存需要的信息，对于本例就是和式的值、$cnt(U)、cnt(R)$，那么定义的乘法就可以计算了。</p><p>记 $f(a,b,c,n,f_U,f_R)$，为将和式 $\sum_{i=1}^{n} \left \lfloor \frac{ai+b}{c} \right \rfloor$ 形成的字符串中的 $\texttt{U}$ 换成 $f_U$，$\texttt{R}$ 换成 $f_R$ 得到的连乘式的值。需要快速计算 $f(a,b,c,d,n,f_U,f_R)$。</p><p>将线段上下平移整数格是不改变函数的值的，所以</p><script type="math/tex; mode=display">f(a,b,c,n,f_U,f_R) = f(a,b\%c,c,n,f_U,f_R)</script><p>考虑对 $a,c$ 的大小分讨</p><ul><li><p>$a \ge c$</p><script type="math/tex; mode=display">  f(a,b,c,n,f_U,f_R) = f(a\%c,b,c,n,f_U,f_U^{\left \lfloor \frac{a}{c} \right \rfloor} f_R)</script></li><li><p>$a &lt; c$<br>  需要将线段沿 $y=x$ 翻转，因为翻转后对于在线段上的顶点加入 $\texttt{U,R}$ 的顺序问题，还需要将线段向右平移 $\frac{1}{c}$，后面就是推式子了，懒得写了，抛出结论，记 $m = \left \lfloor \frac{an+b}{c} \right \rfloor$</p><ul><li><p>$m=0$</p><script type="math/tex; mode=display">  f(a,b,c,n,f_U,f_R) = f_R^n</script></li><li><p>$m \ne 0$</p><script type="math/tex; mode=display">  f(a,b,c,n,f_U,f_R) = f_R^{\left \lfloor \frac{c-b-1}{a} \right \rfloor}  f_U f(c,c-b-1,a,m-1,f_R,f_U) f_R^{n-\left \lfloor \frac{cm-b-1}{a} \right \rfloor}</script></li></ul></li></ul><p>计算时间复杂度，当 $a&lt;c$ 时，有</p><script type="math/tex; mode=display">T(a,c)=T(c\%a,a)+O(\log(\frac{c}{a}))</script><p>最后得到 $T(a,c)=O(\log c)$。</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h4 id="1-【模板】类欧几里得算法"><a href="#1-【模板】类欧几里得算法" class="headerlink" title="1.【模板】类欧几里得算法"></a><a href="https://www.luogu.com.cn/problem/P5170">1.【模板】类欧几里得算法</a></h4><p>考虑合并，记 $f,g,h$ 分别为 $\sum_{i=1}^{n} \left \lfloor \frac{ai+b}{c} \right \rfloor$，$\sum_{i=1}^{n} i\left \lfloor \frac{ai+b}{c} \right \rfloor$，$\sum_{i=1}^{n} \left \lfloor \frac{ai+b}{c} \right \rfloor^2$ 的值，$U,R$ 为 $\texttt{U,R}$ 的个数。</p><script type="math/tex; mode=display">U_1U_2 = U_1 + U_2 \\R_1R_2 = R_1 + R_2</script><script type="math/tex; mode=display">\begin{align}f_1f_2 = f_1+f_2+n_2U_1\end{align}</script><script type="math/tex; mode=display">\begin{align}g_1g_2 &= g_1 + \sum_{i=1}^{n_2} (i+R_1)(\left \lfloor \frac{ai+b}{c} \right \rfloor + U_1) \\&= g_1 + g_2 + R_1f_2 + U_1 \frac{n_2(n_2+1)}{2} + n_2U_1R_1\end{align}</script><script type="math/tex; mode=display">\begin{align}h_1h_2 &= h_1 + \sum_{i=1}^{n_2} (\left \lfloor \frac{ai+b}{c} \right \rfloor + U_1)^2 \\&= h_1 + h_2 + 2U_1f_2 + n_2U_1^2\end{align}</script><p>套用公式即可。</p><h4 id="2-类欧几里得算法"><a href="#2-类欧几里得算法" class="headerlink" title="2.类欧几里得算法"></a><a href="https://loj.ac/p/138">2.类欧几里得算法</a></h4><p>二项式定理。</p><h4 id="3-万能欧几里得"><a href="#3-万能欧几里得" class="headerlink" title="3.万能欧几里得"></a><a href="https://loj.ac/p/6440">3.万能欧几里得</a></h4><script type="math/tex; mode=display">\begin{align}C_1C_2 &= C_1 + \sum_{i=1}^{n_2}A^{i+R_1}B^{\left \lfloor \frac{ai+b}{c} \right \rfloor + U_1} \\&=C_1 + A^{R_1} C_2 B^{U_1}\end{align}</script><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.luogu.com.cn/article/0kkpowmz">类欧几里得</a> </p><p><a href="https://www.luogu.com.cn/article/0nty0w8p">万能欧几里得</a></p>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>矩阵加速图上问题</title>
      <link href="/notes/%E7%9F%A9%E9%98%B5%E5%8A%A0%E9%80%9F%E5%9B%BE%E4%B8%8A%E9%97%AE%E9%A2%98/"/>
      <url>/notes/%E7%9F%A9%E9%98%B5%E5%8A%A0%E9%80%9F%E5%9B%BE%E4%B8%8A%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>图上游走问题。</p><p>邻接矩阵的 $k$ 次幂为图上通过 $k$ 条边到达的方案数。</p><p>矩阵乘向量的时间复杂度为 $O(n^2)$。对于求 $\vec vA^k$，可以预处理</p><script type="math/tex; mode=display">A^1,A^2,...,A^{B} \\A^{B},A^{B^2},...,A^{B^{\log_B k}}</script><p>时间复杂度 $O(n^3(B+\log_B k))-O(n^2\log_B k)$。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.luogu.com.cn/article/s0f38vwf">矩阵加速图上问题</a></p>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>艹</title>
      <link href="/others/%E8%89%B9/"/>
      <url>/others/%E8%89%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="1-不要在模意义下判特殊数据"><a href="#1-不要在模意义下判特殊数据" class="headerlink" title="1.不要在模意义下判特殊数据"></a>1.不要在模意义下判特殊数据</h2><p><a href="https://mirror.codeforces.com/contest/2043/problem/F">Nim</a></p><h2 id="2-lambda-表达式"><a href="#2-lambda-表达式" class="headerlink" title="2.lambda 表达式"></a>2.lambda 表达式</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">auto</span> f = [a]()&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;;</span><br><span class="line">    a=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">f</span>()); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出 $1$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">auto</span> f = [&amp;a]()&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    a=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">f</span>()); </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>输出 $0$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">auto</span> f = [&amp;a]()&#123;</span><br><span class="line">        a=<span class="number">0</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">f</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出 $0$。</p><h2 id="3-用-a-1-来判断-a-是否存在，但是-a-in-infty-infty"><a href="#3-用-a-1-来判断-a-是否存在，但是-a-in-infty-infty" class="headerlink" title="3.用 $a=-1$ 来判断 $a$ 是否存在，但是 $a \in (-\infty,\infty)$"></a>3.用 $a=-1$ 来判断 $a$ 是否存在，但是 $a \in (-\infty,\infty)$</h2>]]></content>
      
      
      <categories>
          
          <category> others </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>斯坦纳树</title>
      <link href="/notes/%E6%96%AF%E5%9D%A6%E7%BA%B3%E6%A0%91/"/>
      <url>/notes/%E6%96%AF%E5%9D%A6%E7%BA%B3%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>使关键点连通的最小树。</p><p><a href="https://www.luogu.com.cn/problem/P6192">【模板】最小斯坦纳树</a></p><p>考虑状压 DP，记 $f(u,S)$ 为以 $u$ 为根，包含 $S$ 集合的特殊点的最小树。</p><p>将最终的树找出来，对于度数为 $1$ 的点，需要加边，即 $f(u,S) \gets f(v,S) + w$。还需要合并，即 $f(u,S) \gets f(u,S’)+f(u,S \oplus S’)(S’ \subset S)$。</p><p>第一种转移用最短路，第二种转移枚举子集。</p><p>时间复杂度 $O(n3^n+nm2^n)/O(n3^n+m\log m2^n)$。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ar(x) array<span class="string">&lt;int,x&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100</span><span class="number">+10</span>,M=<span class="number">500</span><span class="number">+10</span>,L=(<span class="number">1</span>&lt;&lt;<span class="number">10</span>)<span class="number">+10</span>,INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">chkmin</span><span class="params">(<span class="type">int</span> &amp;x,<span class="type">int</span> y)</span></span>&#123; <span class="keyword">return</span> y&lt;x?x=y,<span class="number">1</span>:<span class="number">0</span>; &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> gc getchar()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rd read()</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> x=<span class="number">0</span>,f=<span class="number">0</span>; <span class="type">char</span> c=gc;</span><br><span class="line"><span class="keyword">for</span>(;c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>;c=gc) f|=(c==<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span>(;c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>;c=gc) x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(c^<span class="number">48</span>);</span><br><span class="line"><span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,K,vis[N],f[L][N];</span><br><span class="line">vector&lt;ar(2)&gt; G[N]; queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">n=rd,m=rd,K=rd;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,x,y,z;i&lt;=m;++i) G[x=rd].<span class="built_in">pb</span>(&#123;y=rd,z=rd&#125;),G[y].<span class="built_in">pb</span>(&#123;x,z&#125;);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> S=<span class="number">0</span>;S&lt;(<span class="number">1</span>&lt;&lt;K);++S) <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i) f[S][i]=INF;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,x;i&lt;=K;++i) x=rd,f[<span class="number">1</span>&lt;&lt;(i<span class="number">-1</span>)][x]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> S=<span class="number">0</span>;S&lt;(<span class="number">1</span>&lt;&lt;K);++S)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> T=S;T;T=(T<span class="number">-1</span>)&amp;S) <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i) f[S][i]=<span class="built_in">min</span>(f[S][i],f[T][i]+f[S^T][i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="keyword">if</span>(f[S][i]!=INF) q.<span class="built_in">push</span>(i),vis[i]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line"><span class="type">int</span> u=q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>(),vis[u]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> [v,w]:G[u]) <span class="keyword">if</span>(<span class="built_in">chkmin</span>(f[S][v],f[S][u]+w)&amp;&amp;!vis[v]) q.<span class="built_in">push</span>(v),vis[v]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ans=INF; <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i) ans=<span class="built_in">min</span>(ans,f[(<span class="number">1</span>&lt;&lt;K)<span class="number">-1</span>][i]); <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h4 id="1-JLOI2015-管道连接"><a href="#1-JLOI2015-管道连接" class="headerlink" title="1.[JLOI2015] 管道连接"></a><a href="https://www.luogu.com.cn/problem/P3264">1.[JLOI2015] 管道连接</a></h4><p>最终答案为斯坦纳森林。先求任意子集的斯坦纳树，再套个状压 DP 即可。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.luogu.com.cn/article/m5jej3t8">斯坦纳树</a></p>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Pollard Rho</title>
      <link href="/notes/Pollard_Rho/"/>
      <url>/notes/Pollard_Rho/</url>
      
        <content type="html"><![CDATA[<h2 id="Miller-Rabin"><a href="#Miller-Rabin" class="headerlink" title="Miller Rabin"></a>Miller Rabin</h2><p><a href="https://www.luogu.com.cn/problem/SP288">PON - Prime or Not</a></p><ul><li><p>若 $p$ 为素数，那么 $\forall p \nmid a, a^{p-1} \equiv 1 (\mod p)$。</p></li><li><p>若 $p$ 为奇素数，那么 $x^2 \equiv 1(\mod p)$ 的解为 $x \equiv \pm 1(\mod p)$。</p></li></ul><p>取前 $12$ 个素数（$2,3,5,7,11,13,17,19,23,29,31,37$）就够用了。<a href="https://oeis.org/A014233">OEIS</a>。</p><p>时间复杂度 $O(\log V)$。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">qm</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> p)</span></span>&#123; <span class="type">int</span> res=<span class="number">1</span>; <span class="keyword">for</span>(;y;y&gt;&gt;=<span class="number">1</span>,x=(i128)x*x%p) <span class="keyword">if</span>(y&amp;<span class="number">1</span>) res=(i128)res*x%p; <span class="keyword">return</span> res; &#125;</span><br><span class="line"><span class="type">int</span> pr[<span class="number">15</span>]=&#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">17</span>,<span class="number">19</span>,<span class="number">23</span>,<span class="number">29</span>,<span class="number">31</span>,<span class="number">37</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">chk</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> d=p<span class="number">-1</span>,cur; <span class="keyword">for</span>(;!(d&amp;<span class="number">1</span>);d&gt;&gt;=<span class="number">1</span>);</span><br><span class="line">cur=<span class="built_in">qm</span>(x,d,p); <span class="keyword">if</span>(cur==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(;d&lt;=p<span class="number">-1</span>;d&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(cur==p<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">cur=(i128)cur*cur%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">chk</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(p&gt;<span class="number">37</span>)&#123; <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">12</span>;++i) <span class="keyword">if</span>(!<span class="built_in">chk</span>(pr[i],p)) <span class="keyword">return</span> <span class="number">0</span>; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line"><span class="keyword">else</span>&#123; <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">12</span>;++i) <span class="keyword">if</span>(pr[i]==p) <span class="keyword">return</span> <span class="number">1</span>; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Pollard-Rho"><a href="#Pollard-Rho" class="headerlink" title="Pollard Rho"></a>Pollard Rho</h2><p><a href="https://www.luogu.com.cn/problem/P4718">【模板】Pollard-Rho</a></p><p>构造函数 $f(x)=x^2+c$，记 $x_0=0,x_i=f(x_{i-1})$。</p><p>每次找 $\gcd(\Delta x,p)$ 是很优的。</p><p>$x_i$ 会形成类似 $\rho$ 的图形，由生日悖论可知其长度期望为 $O(\sqrt[4]{p})$，考虑枚举 $i$，当 $x_{2i}=x_i$ 时退出，这样来判环。</p><p>期望时间复杂度 $O(\sqrt[4]{n}\log n)$。</p><p>根据 $\gcd(a,n) \mid \gcd(ab \mod n,n)$，将 $\Delta x$ 乘起来，达到一定限度是求 $\gcd$ 判断。</p><p>对限度倍增，与 $128$ 取 $\min$ 较优。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> get(l,r) (rnd()%((r)-(l)+1)+(l))</span></span><br><span class="line"><span class="function">mt19937_64 <span class="title">rnd</span><span class="params">(time(<span class="number">0</span>))</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">qm</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> p)</span></span>&#123; <span class="type">int</span> res=<span class="number">1</span>; <span class="keyword">for</span>(;y;y&gt;&gt;=<span class="number">1</span>,x=(i128)x*x%p) <span class="keyword">if</span>(y&amp;<span class="number">1</span>) res=(i128)res*x%p; <span class="keyword">return</span> res; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">div</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> c=<span class="built_in">get</span>(<span class="number">1</span>,p<span class="number">-1</span>),s=c,t=<span class="number">0</span>,prod=<span class="number">1</span>,lim=<span class="number">1</span>,cnt=<span class="number">0</span>,d;</span><br><span class="line"><span class="keyword">auto</span> f=[&amp;](<span class="type">int</span> x)&#123; <span class="built_in">return</span> ((i128)x*x+c)%p; &#125;;</span><br><span class="line"><span class="keyword">for</span>(;s!=t;s=<span class="built_in">f</span>(<span class="built_in">f</span>(s)),t=<span class="built_in">f</span>(t))&#123;</span><br><span class="line">prod=(i128)prod*<span class="built_in">abs</span>(s-t)%p;</span><br><span class="line"><span class="keyword">if</span>(++cnt==lim)&#123;</span><br><span class="line"><span class="keyword">if</span>((d=__gcd(prod,p))!=<span class="number">1</span>) <span class="keyword">return</span> d;</span><br><span class="line">cnt=<span class="number">0</span>,lim=<span class="built_in">min</span>(lim&lt;&lt;<span class="number">1</span>,B);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>((d=__gcd(prod,p))!=<span class="number">1</span>) <span class="keyword">return</span> d; <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(p==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">chk</span>(p)) <span class="keyword">return</span> p;</span><br><span class="line"><span class="type">int</span> d=<span class="built_in">div</span>(p); <span class="keyword">for</span>(;d==p;d=<span class="built_in">div</span>(p));</span><br><span class="line"><span class="keyword">for</span>(;p%d==<span class="number">0</span>;p/=d);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">find</span>(d),<span class="built_in">find</span>(p));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/812-xiao-wen/p/10544546.html">Pollard Rho</a></p><p><a href="https://www.cnblogs.com/alex-wei/p/Number_Theory_II.html">初等数论学习笔记 II：分解质因数 </a></p>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>二分图</title>
      <link href="/notes/%E4%BA%8C%E5%88%86%E5%9B%BE/"/>
      <url>/notes/%E4%BA%8C%E5%88%86%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h2><p><a href="https://www.luogu.com.cn/problem/P3386">【模板】二分图最大匹配</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=ne[i])&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[v[i]]) <span class="keyword">continue</span>; vis[v[i]]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(!mat[v[i]]||<span class="built_in">dfs</span>(mat[v[i]]))</span><br><span class="line"><span class="keyword">return</span> mat[v[i]]=u,vis[v[i]]=<span class="number">0</span>,<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度 $O(nm)$。</p><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><blockquote><p>$二分图最小覆盖点数=二分图最大匹配$。</p></blockquote><p>就是 menger 定理的点形式。</p><p>求出最大匹配，遍历每一个未匹配的左部点，将增广路标记。</p><p>取未标记的左部点和标记的右部点作为点覆盖。</p><p><a href="https://www.cnblogs.com/C202202chenkelin/p/14437260.html">证明</a></p><blockquote><p>$二分图最大独立集=n-二分图最大匹配$。</p></blockquote><p>最小点覆盖的补集。</p><blockquote><p>补图的最大独立集为原图的最大团。</p></blockquote><h2 id="hall-定理"><a href="#hall-定理" class="headerlink" title="hall 定理"></a>hall 定理</h2><p>对于点数分别为 $x,y(x \le y)$ 的二分图，若其最大匹配为 $x$ 那么称其有完备匹配。</p><blockquote><p>二分图存在完备匹配当且仅当 $\forall |S| \le |N(S)|$。</p></blockquote><p>归纳法，每次删掉一对。</p><blockquote><p>二分图最大匹配为 $x - \max\{|S|-|N(S)|\}$。</p></blockquote><p>归纳法，每次删掉一对。</p><p><a href="https://www.luogu.com.cn/problem/P3679">[CERC2016] 二分毯 Bipartite Blanket</a></p><p>存在匹配同时覆盖 $X,Y$，当且仅当存在匹配覆盖左部点集 $X$，且存在匹配覆盖右部点集 $Y$。</p><p>证明考虑将两个匹配拼起来，对于偶环/奇链，间隔选择即可。对于偶链，假设左部点多于右部点，一定存在一个左部点 $\notin X$，删去即可。</p><h2 id="二分图博弈"><a href="#二分图博弈" class="headerlink" title="二分图博弈"></a>二分图博弈</h2><p>在二分图上两个人轮流移动一个棋子，不能经过重复节点，不能动者输。</p><p>那么先手必胜当且仅当初始位置为必须点。</p><h2 id="必经可行点边"><a href="#必经可行点边" class="headerlink" title="必经可行点边"></a>必经可行点边</h2><p>跑二分图最大匹配，在残量网络上跑强连通分量（包括 $s,t$）。</p><ul><li><p>若一条边为匹配边且两个端点不属于同一个强连通分量，那么它为必须边。</p></li><li><p>若一条边为匹配边或两个端点属于同一个强连通分量，那么它为可行边。</p></li><li><p>从 $s$ 开始标记能达到的左部点，从 $t$ 开始标记能达到的右部点，那么被标记的点均为非必须点，其补集为必须点。</p></li><li><p>若一个点存在一条相邻的可行边，那么它是可行点。</p></li></ul><h2 id="染色"><a href="#染色" class="headerlink" title="染色"></a>染色</h2><p><a href="https://www.luogu.com.cn/problem/CF600F">Edge coloring of bipartite graph</a></p>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>最小割树</title>
      <link href="/notes/%E6%9C%80%E5%B0%8F%E5%89%B2%E6%A0%91/"/>
      <url>/notes/%E6%9C%80%E5%B0%8F%E5%89%B2%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><a href="https://www.luogu.com.cn/problem/P4897">【模板】最小割树（Gomory-Hu Tree）</a></p><p>考虑建树，对于集合 $S$ 取出两个节点 $x,y$，求 $x \to y$ 的最小割，树上连边 $(x,y)$ 边权为最小割。划分为两个集合递归下去。</p><p>用 dinic 求解，时间复杂度 $O(n^3m)$。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ar(x) array<span class="string">&lt;int,x&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">500</span><span class="number">+10</span>,M=<span class="number">1500</span><span class="number">+10</span>,INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> gc getchar()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rd read()</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> x=<span class="number">0</span>,f=<span class="number">0</span>; <span class="type">char</span> c=gc;</span><br><span class="line"><span class="keyword">for</span>(;c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>;c=gc) f|=(c==<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span>(;c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>;c=gc) x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(c^<span class="number">48</span>);</span><br><span class="line"><span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,id[N],_id[N];</span><br><span class="line">vector&lt;ar(2)&gt; G[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> head[N],ne[M*<span class="number">4</span>],v[M*<span class="number">4</span>],fl[M*<span class="number">4</span>],tot=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> f)</span></span>&#123;</span><br><span class="line">ne[++tot]=head[x],head[x]=tot,v[tot]=y,fl[tot]=f;</span><br><span class="line">ne[++tot]=head[y],head[y]=tot,v[tot]=x,fl[tot]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> s,t,dis[N],cur[N]; queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i) dis[i]=<span class="number">-1</span>,cur[i]=head[i];</span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) q.<span class="built_in">pop</span>(); q.<span class="built_in">push</span>(s),dis[s]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line"><span class="type">int</span> u=q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=ne[i])&#123;</span><br><span class="line"><span class="keyword">if</span>(dis[v[i]]==<span class="number">-1</span>&amp;&amp;fl[i])&#123;</span><br><span class="line">dis[v[i]]=dis[u]<span class="number">+1</span>,q.<span class="built_in">push</span>(v[i]);</span><br><span class="line"><span class="keyword">if</span>(v[i]==t) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dinic</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> df)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(u==t) <span class="keyword">return</span> df; <span class="type">int</span> res=df;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=cur[u];res&amp;&amp;i;i=ne[i])&#123;</span><br><span class="line">cur[u]=i;</span><br><span class="line"><span class="keyword">if</span>(dis[v[i]]==dis[u]<span class="number">+1</span>&amp;&amp;fl[i])&#123;</span><br><span class="line"><span class="type">int</span> k=<span class="built_in">dinic</span>(v[i],<span class="built_in">min</span>(res,fl[i]));</span><br><span class="line"><span class="keyword">if</span>(!k) dis[v[i]]=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">else</span> res-=k,fl[i]-=k,fl[i^<span class="number">1</span>]+=k;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> df-res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span>;</span><br><span class="line"><span class="type">int</span> dflow=<span class="number">0</span>,maxflow=<span class="number">0</span>,_l=l<span class="number">-1</span>,_r=r<span class="number">+1</span>; s=id[l],t=id[r];</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">bfs</span>()) <span class="keyword">while</span>(dflow=<span class="built_in">dinic</span>(s,INF)) maxflow+=dflow; <span class="built_in">bfs</span>();</span><br><span class="line">G[id[l]].<span class="built_in">pb</span>(&#123;id[r],maxflow&#125;),G[id[r]].<span class="built_in">pb</span>(&#123;id[l],maxflow&#125;);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=tot;i+=<span class="number">2</span>) fl[i]+=fl[i^<span class="number">1</span>],fl[i^<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;=r;++i)&#123;</span><br><span class="line"><span class="keyword">if</span>(dis[id[i]]!=<span class="number">-1</span>) _id[++_l]=id[i];</span><br><span class="line"><span class="keyword">else</span> _id[--_r]=id[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;=r;++i) id[i]=_id[i];</span><br><span class="line"><span class="built_in">sol</span>(l,_l),<span class="built_in">sol</span>(_r,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> tmp[N],ans[N][N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fu,<span class="type">int</span> mn)</span></span>&#123; tmp[u]=mn; <span class="keyword">for</span>(<span class="keyword">auto</span> [v,w]:G[u]) <span class="keyword">if</span>(v!=fu) <span class="built_in">dfs</span>(v,u,<span class="built_in">min</span>(mn,w)); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">n=rd<span class="number">+1</span>,m=rd;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i) id[i]=i;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,x,y,z;i&lt;=m;++i) x=rd<span class="number">+1</span>,y=rd<span class="number">+1</span>,z=rd,<span class="built_in">add</span>(x,y,z),<span class="built_in">add</span>(y,x,z);</span><br><span class="line"></span><br><span class="line"><span class="built_in">sol</span>(<span class="number">1</span>,n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">dfs</span>(i,<span class="number">0</span>,INF),<span class="built_in">memcpy</span>(ans[i],tmp,<span class="number">4</span>*(n<span class="number">+1</span>));</span><br><span class="line">m=rd; <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans[rd<span class="number">+1</span>][rd<span class="number">+1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h4 id="1-Pumping-Stations"><a href="#1-Pumping-Stations" class="headerlink" title="1.Pumping Stations"></a><a href="https://www.luogu.com.cn/problem/CF343E">1.Pumping Stations</a></h4><p>先建最小割树。</p><p>取出最小边考虑，它一定会被计入答案一次，删掉它形成两棵树，两棵树可以随便选定起点，这样已经很自由了，所以分别遍历再拼起来即可。</p><h4 id="2-曼哈顿计划EX"><a href="#2-曼哈顿计划EX" class="headerlink" title="2.曼哈顿计划EX"></a><a href="https://www.luogu.com.cn/problem/P3729">2.曼哈顿计划EX</a></h4><p>询问可以指针，但瓶颈不在这。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.luogu.com.cn/article/cnyjwh6a">最小割树</a></p>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>网络流</title>
      <link href="/notes/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
      <url>/notes/%E7%BD%91%E7%BB%9C%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>有个建反向边的反悔思想。</p><h3 id="FF-算法（指用-dfs-实现的-FF）"><a href="#FF-算法（指用-dfs-实现的-FF）" class="headerlink" title="FF 算法（指用 dfs 实现的 FF）"></a>FF 算法（指用 dfs 实现的 FF）</h3><p>dfs 找增广路。</p><p>每次增广当前流量至少加 $1$，单次增广时间复杂度 $O(m)$。记 $F$ 为最大流，时间复杂度为 $O(Fm)$。</p><h3 id="EK-算法"><a href="#EK-算法" class="headerlink" title="EK 算法"></a>EK 算法</h3><p>bfs 找到增广路。</p><p>时间复杂度为 $O(nm^2)$。</p><p>下面是证明。</p><blockquote><p>每次增广后 $s$ 到除 $s$ 外每个点的最短路单调不降。</p></blockquote><p>反证法，记 $d_u$ 为原最短路，$d’_u$ 为增广后的最短路，假设存在点 $u$ 满足 $d’_u&lt;d_u$ 取 $d’_u$ 最小的点作为 $u$。</p><p>设增广后的最短路径形如 $s \leadsto x \to u$。那么 $d’u=d’x+1$。</p><p>此时 $(x,u) \notin E$，否则 $d_u \le d_x+1 \le d’_x+1 = d’_u$ 矛盾。</p><p>那么 $(x,u)$ 是增广后的反向边，即 $(u,x) \in E$。有 $d_u+1=d_x \le d’_x = d’_u-1$，即 $d_u \le d’_u-2$ 矛盾。</p><blockquote><p>记一次增广流量等于增广流量的边为关键边，那么每条边最多成为 $\frac{n}{2}-1$ 次关键边。</p></blockquote><p>若 $(u,v)$ 作为关键边，其再次出现需要 $(v,u)$ 作为关键边。那么 $ d_u = d_v-1 \le d’_v-1 = d’_u-2 $，而 $d$ 最小为 $1$ 最大为 $n-1$，最多出现 $\frac{n}{2}-1$ 次。</p><p>那么总增广次数为 $O(nm)$，单次增广时间复杂度 $O(m)$，总时间复杂度 $O(nm^2)$。</p><h3 id="dinic"><a href="#dinic" class="headerlink" title="dinic"></a>dinic</h3><p><a href="https://www.luogu.com.cn/problem/P3376">1.【模板】网络最大流</a> <a href="https://www.luogu.com.cn/paste/n5dv07nc">dinic</a></p><p><a href="https://www.luogu.com.cn/problem/P3381">2.【模板】最小费用最大流</a> <a href="https://www.luogu.com.cn/paste/dcnzzkwo">dinic</a></p><ul><li><p>对于一般网络，时间复杂度为 $O(n^2m)$。</p></li><li><p>对于容量为 $1$ 的网络，时间复杂度为 $O(m\min(n^{\frac{2}{3}},\sqrt{m}))$。</p></li><li><p>对于单位网络，即满足 $\min(d_i^{in},d_i^{out}) \le 1$ 且容量为 $1$ 的网络，时间复杂度为 $O(m\sqrt{n})$。</p></li><li><p>增广轮数为 $O(\sqrt{\sum_{i}\min(d_i^{in},d_i^{out})})$。</p></li></ul><p>下面是证明。</p><blockquote><p>每次增广后到 $t$ 的最短路单调不减。</p></blockquote><p>同理可证。</p><blockquote><p>dinic 算法每次增广后 $s$ 到 $t$ 的最短路单调递增。</p></blockquote><p>只需证明不相等，反证法，假设增广后最短路单调递增。</p><p>那么一定存在一条边 $e \notin E$，否则会被增广。那么 $d \ge d’+2$ 矛盾。</p><blockquote><p>对于一般图，dinic 算法时间复杂度为 $O(n^2m)$。</p></blockquote><p>会增广 $O(n)$ 轮，每轮增广会增广 $O(m)$ 次，每次增广时间复杂度 $O(n)$（分层图），总时间复杂度 $O(n^2m)$。</p><blockquote><p>记 $S=\sum_{i}\min(d_i^{in},d_i^{out})$，那么增广轮数为 $O(\sqrt{S})$。</p></blockquote><p>若增广超过 $O(\sqrt{S})$ 轮，那么之后的增广路长度 $&gt;\sqrt{S}$。</p><p>将达到终态需要增广的路径提出来，对每个点分别考虑可得其总长度 $\le S$，那么路径数为 $O(\sqrt{S})$，则接下来至多增广 $O(\sqrt{S})$ 轮。</p><blockquote><p>边容量为 $1$ 的网络，增广轮数为 $O(\sqrt{m})$。</p></blockquote><p>$S=m$。</p><blockquote><p>边容量为 $1$ 的网络，增广轮数为 $O(n^{\frac{2}{3}})$。</p></blockquote><p>记 $s_i$ 为与 $s$ 最短距离为 $i$ 的点的个数，记 $d$ 为 $s$ 到 $t$ 的最短距离，记 $F$ 为最大流，有 $F \le s_is_{i+1} \le (\frac{s_i+s_{i+1}}{2})^2(i=0,1,…,d-1)$。</p><p>而 $\sum_{i=0}^{d-1} \frac{s_i+s_{i+1}}{2} &lt; n$，故 $F &lt; \frac{n^2}{d^2}$。</p><p>还有个增广轮数 $\le d$ 的限制，那么当 $d \le n^{\frac{2}{3}}$ 时，增广轮数为 $O(n^{\frac{2}{3}})$，当 $d &gt; n^{\frac{2}{3}}$ 时，增广轮数为 $O(n^{\frac{2}{3}})$。</p><blockquote><p>边容量为 $1$ 的网络，单次增广的时间复杂度为 $O(m)$。</p></blockquote><p>每条边至多遍历一次。</p><blockquote><p>单位网络的增广轮数为 $O(\sqrt{n})$。</p></blockquote><p>$S=O(n)$。</p><h2 id="最大流最小割定理"><a href="#最大流最小割定理" class="headerlink" title="最大流最小割定理"></a>最大流最小割定理</h2><p>即 最大流 $=$ 最小割。</p><p>最大流 $\le$ 最小割，只需证明最大流 $\ge$ 最小割。</p><p>只需证明存在一个流等于一个割即可，最终的残余网络显然符合条件。</p><p>其实是对偶。</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h4 id="1-二分图最大匹配"><a href="#1-二分图最大匹配" class="headerlink" title="1.二分图最大匹配"></a>1.二分图最大匹配</h4><p>记 $X,Y$ 分别为左右部点。</p><ul><li><p>$\forall x \in X,(s,x,1)$。</p></li><li><p>$\forall y \in Y,(y,t,1)$。</p></li><li><p>$\forall (x,y) \in E,(x,y,1)$。</p></li></ul><h4 id="2-Matrix-Decompressing"><a href="#2-Matrix-Decompressing" class="headerlink" title="2.Matrix Decompressing"></a><a href="https://www.luogu.com.cn/problem/UVA11082">2.Matrix Decompressing</a></h4><p>求出每行每列的和。将每个点的初始值设为 $1$，范围转化为 $0-19$。</p><p>将每行每列视为一个点。对原图中点 $(x,y)$ 建 $(x,y,19)$。从 $s$ 向每行连容量为当前行的和的边，列向 $t$ 连边。</p><p>跑最大流即可保证行和列均满足和的条件。</p><p>每个点的值即为边的流量 $+1$。</p><p><a href="https://www.luogu.com.cn/paste/4m006v0m">code</a></p><h4 id="3-有负圈的费用流"><a href="#3-有负圈的费用流" class="headerlink" title="3.有负圈的费用流"></a><a href="https://www.luogu.com.cn/problem/P7173">3.有负圈的费用流</a></h4><p>由于有负环，基于最短路的费用流无法直接处理。</p><p>强制让负权边满流，但是这样会使有的点的入流与出流不等。</p><p>若点的入流大于出流，则需要流出一些流，反之则需要流入一些流。用网络流处理。</p><p>建立虚拟源汇点 $s,t$。记 $in_i$ 为点 $i$ 的入流减出流，</p><ul><li><p>$in_i &gt; 0$ 连边 $(s,i,in_i,0)$。</p></li><li><p>$in_i &lt; 0$ 连边 $(i,t,-in_i,0)$。</p></li></ul><p>以虚拟源点跑一次费用流那么原图流量平衡（这叫做可行流），再跑费用流求解。</p><p><a href="https://www.luogu.com.cn/paste/aewu4k9t">code</a></p><h4 id="4-有源汇上下界最大流"><a href="#4-有源汇上下界最大流" class="headerlink" title="4.有源汇上下界最大流"></a><a href="https://www.luogu.com.cn/problem/P5192">4.有源汇上下界最大流</a></h4><p>先强制流满每条边的下界，跑可行流。若不存在可行流（没有满流）则无解。</p><p>特别的，由于原图中的源点、汇点入流不一定等于出流，所以连边 $(t,s,\infty)$。</p><p>跑出可行流后，将 $t$ 到 $s$ 的边删去，再跑一次最大流。可行流加最大流即为答案。</p><p><a href="https://www.luogu.com.cn/paste/2rs524un">code</a></p><h4 id="5-文理分科"><a href="#5-文理分科" class="headerlink" title="5.文理分科"></a><a href="https://www.luogu.com.cn/problem/P4313">5.文理分科</a></h4><p>每个同学要么选文科要么选理科，该问题为划分问题，用最小割来解决。</p><p>对于每个同学，从 $s$ 连一条容量为选文科所得满意值的边，向 $t$ 连一条容量为选理科所得满意值的边，该同学最终与 $s$ 相连即为选了文科，反之理科。</p><p>对于选相同科目的满意值（举都选文科为例），新建一个节点 $i$ 代表以 $i$ 为中心的五位同学</p><p>从 $s$ 连一条容量为全选文科所得满意值的边，向五位同学分别连一条容量为 $\infty$ 的边。</p><p>表示若要获得全选文科所得的满意值，则五位同学的理科边（容量为选理科所得满意值的边）都要割断。</p><p>最大满意值即为剩下的边的边权，用满意度之和减去最小割即可。</p><p><a href="https://www.luogu.com.cn/paste/s1vbg5f8">code</a></p><h4 id="6-骑士共存问题"><a href="#6-骑士共存问题" class="headerlink" title="6.骑士共存问题"></a><a href="https://www.luogu.com.cn/problem/P3355">6.骑士共存问题</a></h4><p>仍可看成划分问题，即每个位置选或不选。限制为选择某个点则周围的点强制不选。</p><p>为了加边满足该限制，一个点与相邻的点的方向应是相反的，即被划分到 $s$ 的含义不同。</p><p>没有奇环，点被合法地分成了两类，对应原图黑白染色的结果。</p><p>建图时流量为 $0$ 的边可以省去，这样就是主流的建图方式了。</p><p>此题的 $\infty$ 可以视为 $1$，发现建图与二分图最大匹配相同，事实上本题就是求二分图最大独立集。</p><h4 id="7-太空飞行计划问题"><a href="#7-太空飞行计划问题" class="headerlink" title="7.太空飞行计划问题"></a><a href="https://www.luogu.com.cn/problem/P2762">7.太空飞行计划问题</a></h4><p>考虑一般的问题，即最大权闭合子图。</p><p>看成划分问题，需要满足一个点被选，那么它的邻点强制被选。</p><p>由于点权有负数，不能直接建图，先加上点权的绝对值即可。</p><p>详细解释。</p><p>对于点权为正的，连边为 $val,0$，答案为 $val-割$（最小割满足保留边的权值最大）。</p><p>对于点权为负的，开始连边 $val,0$，答案为 $val-割$，由于 $val$ 为负，考虑连边 $0,-val$，答案为 $val-(割+val)=0-割$。</p><h4 id="8-Hard-Life"><a href="#8-Hard-Life" class="headerlink" title="8.Hard Life"></a><a href="https://www.luogu.com.cn/problem/UVA1389">8.Hard Life</a></h4><p>通过01分数规划求解。二分 $\frac{|E|}{|V|}$（记为$g$）。要判断是否有</p><script type="math/tex; mode=display">\begin{align}\frac{|E|}{|V|} &> g \\|E|-g|V| &> 0\end{align}</script><p>即求出当前 $|E|-g|V|$ 的最大值。</p><p>二分的下限为 $\frac{1}{n}$ ，上限为 $m$ ，两个不同的密度差最少为 $\frac{1}{n^2}$ 这决定了精度。</p><p>我们使用最小割求解$\left|E\right|-g\left|V\right |$ 的最大值。</p><p>将无向边拆为两条有向边。</p><p>记 $V$ 为与 $s$ 相连的点集，其补集为 $V’$，$C[V,V’]$ 为起点在 $V$，终点在 $V’$ 的边的个数。则</p><script type="math/tex; mode=display">|E|=\frac{\sum_{u \in V}out_u-C[V,V']}{2}</script><p>这样就将边的信息转化为点的信息了。</p><p>考虑如何凑出原式。最小割为下面三种边的容量和</p><ul><li><p>$s \to V’$</p></li><li><p>$V \to t$</p></li><li><p>$V \to V’$</p></li></ul><p>对于边三，可以将原图中的边的容量设为 $1$，得到 $C[V,V’]$。对于边二，设容量为 $2g-out_i$，但是这样会使有的容量为负，加一个 $\Delta$ 即可（用 $m$）。这样会多算 $|V|m$，让边一容量为 $m$。</p><p>最小割即为</p><script type="math/tex; mode=display">mn+C[V,V']+2g|V|-\sum_{u \in V}out_u = mn+2gn-2m</script><p>所以 $m-gn=\frac{(mn-\texttt{maxflow})}{2}$。</p><p><a href="https://www.luogu.com.cn/paste/epvrztkw">code</a></p><h4 id="9-最小路径覆盖问题"><a href="#9-最小路径覆盖问题" class="headerlink" title="9.最小路径覆盖问题"></a><a href="https://www.luogu.com.cn/problem/P2764">9.最小路径覆盖问题</a></h4><p>将每个点看作一条路径，每次可以首尾合并两条路径。</p><p>将每个点拆为 $in,out$，对于边 $u \to v$，连边 $(out_u,in_v,1)$。</p><p>跑二分图最大匹配即可。</p><p>对于允许链相交的问题，先跑传递闭包，再跑二分图最大匹配。</p><h4 id="10-CTSC2008-祭祀"><a href="#10-CTSC2008-祭祀" class="headerlink" title="10.[CTSC2008] 祭祀"></a><a href="https://www.luogu.com.cn/problem/P4298">10.[CTSC2008] 祭祀</a></h4><blockquote><p>一个 DAG 中最长反链的大小，等于最小链覆盖的大小。</p></blockquote><p>由鸽巢原理可知，最长反链 $\le$ 最小链覆盖。只需构造方案即可。</p><p>将原图传递闭包后拆点建出二分图，标记最大独立集中的点，若原图中点的入点与出点均被标记，则该点属于最长反链。</p><p>一个点的入点与出点均在独立集中，反映到原图上，则它与其他反链上的点均未直接相连，所以选出的点一定为反链。</p><p>由于最小链覆盖 $=n-$ 最大匹配数、最大独立集 $=2n-$ 最大匹配数，所以最小链覆盖 $=$ 最大独立集 $-n$。</p><p>那么只要每个点至少有一个入点或出点被标记，则选出的方案为最大反链。可以反证法证明。</p><p>若点 $i$ 的入点（$i’$）与出点（ $i’’$ ）均未被标记，则必有 $j’’$ 与 $i’$ 相连，$k’$ 与 $i’’$ 相连，且 $j’’,k’$ 均被标记。</p><p>由于原图为 DAG 所以 $j,k$ 不为同一点。</p><p>由于先进行了传递闭包，所以若 $j \to i$ 且 $i \to k$ ，则必有 $j \to k$ ，即 $j’’$ 与 $k’$ 相连，此时不满足独立集的条件，故该情况不成立。</p><p>对于第三问，枚举每个点，将与它相连的点删去，再计算最长反链。若此时的最长反链 $=ans-1$，则该点可选，反之不可选。</p><p><a href="https://www.luogu.com.cn/paste/uog5xvyx">code</a></p><h4 id="11-最长k可重区间集问题"><a href="#11-最长k可重区间集问题" class="headerlink" title="11.最长k可重区间集问题"></a><a href="https://www.luogu.com.cn/problem/P3358">11.最长k可重区间集问题</a></h4><p>限制是 $\le k$ 考虑网络流，建图看看得了，感觉就是妙手偶得啊，不会讲。</p><h4 id="12-CTSC1999-家园-星际转移问题"><a href="#12-CTSC1999-家园-星际转移问题" class="headerlink" title="12.[CTSC1999] 家园/星际转移问题"></a><a href="https://www.luogu.com.cn/problem/P2754">12.[CTSC1999] 家园/星际转移问题</a></h4><p>太空船只可容纳 $h$ 个人，即太空船最多容纳 $h$ 个人，可以发现是容量的定义，用网络流求解</p><p>由于太空船移动的特殊性和极小的数据范围，我们可以想到枚举答案、动态加边，直到 $k$ 个人运出输出此时的答案。</p><p>每次在可以上一次的残量网络上跑最大流。</p><p>对于无解的判断，如果地球和月球无法通过太空船相连即无解，用并查集判断。</p><p><a href="https://www.luogu.com.cn/paste/cl4n46ve">code</a></p><h4 id="13-NOI2010-海拔"><a href="#13-NOI2010-海拔" class="headerlink" title="13.[NOI2010] 海拔"></a><a href="https://www.luogu.com.cn/problem/P2046">13.[NOI2010] 海拔</a></h4><p>先贪心一下，最后的图一定为一片 $1$ 与一片 $0$。</p><p>所以该题就转化为了最小割问题，但是用最大流求最小割会超时。</p><p>图为平面图，我们可以将平面图最小割转化为对偶图最短路。</p><p>具体地，将平面图中每一个平面看作一个节点，将两个平面之间的邻边转化为两个节点之间的边。</p><p>对于最上侧和最右侧的边，将它看作 $s$ 与所在平面的边。</p><p>对于最下侧和最左侧的边，将它看作 $t$ 与所在平面的边。</p><p>例如，$i$ 与 $j$ 平面上下相邻，对于中间从西到东的邻边，将其转化为 $i \to j$。</p><p>因为若该边计入答案，则西边的节点为 $0$ ，东边的节点为 $1$，所以转化为从上到下的边</p><p>将其他情况都推一遍，可以发现是将原图中的边顺时针旋转 $90$ 度。</p><p><a href="https://www.luogu.com.cn/paste/pssi03u7">code</a></p><h4 id="14-AHOI2009-最小割"><a href="#14-AHOI2009-最小割" class="headerlink" title="14.[AHOI2009] 最小割"></a><a href="https://www.luogu.com.cn/problem/P4126">14.[AHOI2009] 最小割</a></h4><ul><li><p>满流且两端点不在同一连通分量的边为可行边。</p></li><li><p>满流且两端点分别在 $s,t$ 的强连通分量的边为必须边。</p></li></ul><p>将跑任意最大流后得到的残量网络缩点，得到一张 DAG，DAG 上任意紧的割都是原图的最小割。</p><h2 id="杂题"><a href="#杂题" class="headerlink" title="杂题"></a>杂题</h2><h4 id="1-A-Plug-for-UNIX"><a href="#1-A-Plug-for-UNIX" class="headerlink" title="1.A Plug for UNIX"></a><a href="https://www.luogu.com.cn/problem/UVA753">1.A Plug for UNIX</a></h4><p>类似于二分图最大匹配建图</p><ul><li><p>对于插座 $i$ 连 $(i,t,1)$。</p></li><li><p>对于插头 $i$ 连 $(s,i,1)$。</p></li><li><p>对于转换器 $u \to v$ 连 $(u,v,\infty)$。</p></li></ul><p>跑最大流即可。</p><p><a href="https://www.luogu.com.cn/paste/smekujoo">code</a></p><h4 id="2-方格取数加强版"><a href="#2-方格取数加强版" class="headerlink" title="2.方格取数加强版"></a><a href="https://www.luogu.com.cn/problem/P2045">2.方格取数加强版</a></h4><h4 id="3-SCOI2007-修车"><a href="#3-SCOI2007-修车" class="headerlink" title="3.[SCOI2007] 修车"></a><a href="https://www.luogu.com.cn/problem/P2053">3.[SCOI2007] 修车</a></h4><p>等待相当于每次从头开始走一遍。费用流解决。</p><h4 id="4-NOI2008-志愿者招募"><a href="#4-NOI2008-志愿者招募" class="headerlink" title="4.[NOI2008] 志愿者招募"></a><a href="https://www.luogu.com.cn/problem/P3980">4.[NOI2008] 志愿者招募</a></h4><p>类似最小路径覆盖问题，容量为 $\infty-a_i$ 即可。</p><h4 id="5-Help-Little-Laura"><a href="#5-Help-Little-Laura" class="headerlink" title="5.Help Little Laura"></a><a href="https://www.luogu.com.cn/problem/UVA1659">5.Help Little Laura</a></h4><p>给你一个有向图，每条边的权值为 $len \times x-y$ ，找一些不相交的环，使得权值和最大。</p><p>若将每条边的流量定为 $1$ ，则一个合法的涂色方式中每个点的入流与出流相等，跑可行流即可。</p><p><a href="https://www.luogu.com.cn/paste/8e71oeqk">code</a></p><p>还可以每次用 spfa 找一个负环增广。</p><h4 id="6-Euler-Circuit"><a href="#6-Euler-Circuit" class="headerlink" title="6.Euler Circuit"></a><a href="https://www.luogu.com.cn/problem/UVA10735">6.Euler Circuit</a></h4><p>由于欧拉回路中每条边只能经过一次，所以不能简单地将无向边拆为有向边。</p><p>我们需要找一个将无向边定向的方案，使原图存在欧拉回路。那么需要满足每个点的入度减出度为 $0$。</p><p>先随意将无向边定向，记 $in_i$ 为点i的入度减出度。</p><p>将 $u \to v$ 的无向边取反则 $in_u+=2,in_v-=2$，相当于流量从 $u$ 流入 $v$。</p><p>按残量网络建图，再跑欧拉回路即可。</p><p><a href="https://www.luogu.com.cn/paste/820sgya9">code</a></p><h4 id="7-Chips-Challenge"><a href="#7-Chips-Challenge" class="headerlink" title="7.Chips Challenge"></a><a href="https://www.luogu.com.cn/problem/UVA1104">7.Chips Challenge</a></h4><p>由于每一行与每一列的芯片数相同，可以将行与列看成一个点。</p><p>对于 $.(i,j)$，连 $(i,j,1,1)$。</p><p>对于 $C(i,j)$，由于要强制选择，连 $(i,j,1,\infty)$。</p><p>所以题目就转化为一个最大费用可行流问题，除去 $\infty$ 的费用和即为添加的部件个数。</p><p>再考虑 $A/B$ 这个限制。由于 $N$ 较小，可以考虑枚举行或列最多的部件数 $k$。拆点，连 $(i’,i’’,k,0)$。 </p><p>如果 $当前C的个数 \times A&gt;=Bk$ 则合法，取最大值即为 $ans$。</p><p>对于最大费用可行流问题，我们先将边权取反，转化为最小费用可行流。</p><p>自己推一下即可得到如下连边方式</p><ul><li><p>$(i’,i’’,k,0)$。</p></li><li><p>$(s,i’,maxl_i,0)$。</p></li><li><p>$(i’’,t,maxh_i,0)$。</p></li></ul><p>对于$.(i,j)$，连 $(j’,i’’,1,1)$，此处连边是为了删边，由于 $C$ 连的边不需要删，所以可不连该边。</p><p><a href="https://www.luogu.com.cn/paste/6votwsa6">code</a></p><h4 id="8-ZJOI2011-营救皮卡丘"><a href="#8-ZJOI2011-营救皮卡丘" class="headerlink" title="8.[ZJOI2011] 营救皮卡丘"></a><a href="https://www.luogu.com.cn/problem/P4542">8.[ZJOI2011] 营救皮卡丘</a></h4><p><a href="https://www.luogu.com.cn/paste/wrbsbni5">code</a></p><h4 id="9-无限之环"><a href="#9-无限之环" class="headerlink" title="9.无限之环"></a><a href="https://www.luogu.com.cn/problem/P4003">9.无限之环</a></h4><p><a href="https://www.luogu.com.cn/paste/js4jzhd0">code</a></p><h4 id="10-WC2007-剪刀石头布"><a href="#10-WC2007-剪刀石头布" class="headerlink" title="10.[WC2007] 剪刀石头布"></a><a href="https://www.luogu.com.cn/problem/P4249">10.[WC2007] 剪刀石头布</a></h4><p>每个点的贡献可以写成等差数列形式，依次连边即可。</p><h2 id="zkw-费用流"><a href="#zkw-费用流" class="headerlink" title="zkw 费用流"></a>zkw 费用流</h2><p>貌似就是倒着跑 spfa 的 dinic？</p><h2 id="最大流唯一性判定"><a href="#最大流唯一性判定" class="headerlink" title="最大流唯一性判定"></a>最大流唯一性判定</h2><p>跑出残量网络，相当于判断混合图是否有环，将无向边缩点跑拓扑排序即可。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/uid001/p/10465580.html">EK 时间复杂度证明</a></p><p><a href="https://www.cnblogs.com/myee/p/dinic-algorithm.html">Dinic的几种复杂度</a></p><p><a href="https://web.eecs.umich.edu/~pettie/matching/Karzanov-unit-flow-msqrtm-mntwothirds-msqrtn-matching-ENGLISH.pdf">On finding a maximum flow in a network with special structureand some applications 1</a></p><p><a href="https://www.luogu.com.cn/article/li2xfw2r">EK不够快？再学个Dinic吧</a></p><p><a href="https://www.luogu.com.cn/article/k2hh2bok">网络流</a></p><p>某课件</p>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>支配点对</title>
      <link href="/notes/%E6%94%AF%E9%85%8D%E7%82%B9%E5%AF%B9/"/>
      <url>/notes/%E6%94%AF%E9%85%8D%E7%82%B9%E5%AF%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>有用的点对？</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h4 id="1-Tree-Distance"><a href="#1-Tree-Distance" class="headerlink" title="1.Tree Distance"></a><a href="https://qoj.ac/contest/1053/problem/5148">1.Tree Distance</a></h4><p>点分治，记 $d_u$ 为 $u$ 到分治中心的距离，两点间的距离 $\le d_i + d_j$。</p><p>考虑对于每个点找到以其为 $d$ 最大值的点对。</p><p>对于 $i &lt; j &lt; k$，若 $d_i \ge d_j,d_k$ 那么 $(i,k)$ 会被 $(j,k)$ 完全包含。</p><p>先按编号排序，对于每个点找到前面/后面第一个 $d$ 比它小的点，组成点对。</p><p>总共 $O(n\log n)$ 个支配点对。询问相当于二维偏序，扫描线+线段树即可，时间复杂度 $O(n\log^2n)$。</p><h4 id="2-Ynoi2008-rdCcot"><a href="#2-Ynoi2008-rdCcot" class="headerlink" title="2.[Ynoi2008] rdCcot"></a><a href="https://www.luogu.com.cn/problem/P7126">2.[Ynoi2008] rdCcot</a></h4><p>每个 C-块 取 bfs 序最小点作为代表元。</p><p>按编号排序，对每个点求出 $L_i,R_i$ 分别为其左右两边第一个 bfs 序比它小且能与它 C 连通的点。</p><p>询问 $[l,r]$ 的答案为 $\sum_{i=l}^{r} [L_i&lt;l][r&lt;R_i]$，扫描线解决。</p><p>对于 $L,R$ 的求解，由于与距离有关，用点分治，将子树节点按 bfs 序扫描线，线段树二分求出 $L_i,R_i$ 即可。</p><h4 id="3-Ynoi2003-铃原露露"><a href="#3-Ynoi2003-铃原露露" class="headerlink" title="3.[Ynoi2003] 铃原露露"></a><a href="https://www.luogu.com.cn/problem/P8528">3.[Ynoi2003] 铃原露露</a></h4><p>将节点编号按 $a$ 排序。若区间满足题面中 $[L,R]$ 的限制，那么它是合法的。对于 $(x,y,lca(x,y))$</p><ul><li><p>若 $lca(x,y) \in [x,y]$ 无影响。</p></li><li><p>若 $lca(x,y)&lt;x$ 那么区间 $[l,r] (l \in (lca(x,y),x],r \in [y,n])$ 是不合法的。</p></li><li><p>若 $y&lt;lca(x,y)$ 那么区间 $[l,r] (l \in [1,x],r \in [y,lca(x,y)))$ 是不合法的。</p></li></ul><p>相当于二维区间加，查询二维区间 $=0$ 的元素个数。</p><p>扫描线，线段树维护区间最小值及其个数，历史 $=0$ 的元素个数，查询区间历史和。</p><p>对于这种与 lca 有关的点对求解，一般用 dsu on tree 钦定 lca 求解。</p><p>对于特定的 $x$，取前驱后继作为 $y$ 即可，总共 $O(n\log n)$ 个支配点对。</p><p>时间复杂度 $O(n\log^2n)$。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/TetrisCandy/p/18095815">支配点对</a></p>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>莫队</title>
      <link href="/notes/%E8%8E%AB%E9%98%9F/"/>
      <url>/notes/%E8%8E%AB%E9%98%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>将询问离线，按特定方式排序，使得询问之间移动的代价较小。</p><p>求所属块代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) bk[i]=(i<span class="number">-1</span>)/LEN;</span><br></pre></td></tr></table></figure><p>常见常数优化</p><ul><li><p>左端点所在块相同时，按块编号的奇偶将右端点小到大或大到小排序</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp0</span><span class="params">(Q a,Q b)</span></span>&#123; <span class="keyword">return</span> bk[a.l]!=bk[b.l]?bk[a.l]&lt;bk[b.l]:bk[a.l]&amp;<span class="number">1</span>?a.r&lt;b.r:a.r&gt;b.r; &#125;</span><br></pre></td></tr></table></figure></li><li><p>将简单的 add/del 写入 while 循环内</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(ql&lt;dl) dans+=<span class="number">2</span>*cnt[col[--dl]],cnt[col[dl]]++;</span><br><span class="line"><span class="keyword">while</span>(qr&gt;dr) dans+=<span class="number">2</span>*cnt[col[++dr]],cnt[col[dr]]++;</span><br><span class="line"><span class="keyword">while</span>(ql&gt;dl) cnt[col[dl]]--,dans-=<span class="number">2</span>*cnt[col[dl++]];</span><br><span class="line"><span class="keyword">while</span>(qr&lt;dr) cnt[col[dr]]--,dans-=<span class="number">2</span>*cnt[col[dr--]];</span><br></pre></td></tr></table></figure></li></ul><h2 id="普通莫队"><a href="#普通莫队" class="headerlink" title="普通莫队"></a>普通莫队</h2><h4 id="1-国家集训队-小-Z-的袜子"><a href="#1-国家集训队-小-Z-的袜子" class="headerlink" title="1.[国家集训队] 小 Z 的袜子"></a><a href="https://www.luogu.com.cn/problem/P1494">1.[国家集训队] 小 Z 的袜子</a></h4><p>记区间中有 $n$ 种颜色，颜色为 $i$ 的有 $a_i$ 个，则概率为</p><script type="math/tex; mode=display">\frac{\sum_{i=1}^{n}a_i(a_i-1)}{(r-l+1)(r-l)}</script><p>将询问离线，用莫队即可，时间复杂度 $O(n\sqrt{n})$</p><h2 id="带修莫队"><a href="#带修莫队" class="headerlink" title="带修莫队"></a>带修莫队</h2><h4 id="1-国家集训队-数颜色-维护队列"><a href="#1-国家集训队-数颜色-维护队列" class="headerlink" title="1.[国家集训队] 数颜色 / 维护队列"></a><a href="https://www.luogu.com.cn/problem/P1903">1.[国家集训队] 数颜色 / 维护队列</a></h4><p>将时间看作一维，即可变成三维问题 <a href="https://www.luogu.com.cn/paste/8937lvmc">code</a><br>。</p><p>分析时间复杂度，将一次操作看作一个点 $(t,x,y)$，将点按某一顺序排序，那么三个指针移动的总距离就是相邻点曼哈顿距离之和。分别考虑三个指针的移动即可，一般取块长为 $n^{\frac{2}{3}}$，时间复杂度为 $O(n^{\frac{3}{5}})$。</p><h4 id="2-Machine-Learning"><a href="#2-Machine-Learning" class="headerlink" title="2.Machine Learning"></a><a href="https://www.luogu.com.cn/problem/CF940F">2.Machine Learning</a></h4><p>如果没有修改可以用只减不加的回滚莫队。</p><p>此题 mex 是出现个数的，最大为 $\sqrt{n}$。</p><p>所以每次移动完，直接暴力求解即可。</p><p><a href="https://www.luogu.com.cn/paste/mbw2kj1q">code</a></p><h2 id="回滚莫队"><a href="#回滚莫队" class="headerlink" title="回滚莫队"></a>回滚莫队</h2><h4 id="1-【模板】回滚莫队-amp-不删除莫队"><a href="#1-【模板】回滚莫队-amp-不删除莫队" class="headerlink" title="1.【模板】回滚莫队&amp;不删除莫队"></a><a href="https://www.luogu.com.cn/problem/P5906">1.【模板】回滚莫队&amp;不删除莫队</a></h4><p>一些题目删除操作并不好做，可以将其避免。</p><p>考虑计算复杂度的过程，每次 $l$ 指针的移动我们都是按 $\sqrt{n}$ 的次数计算。</p><p>这给了我们很大的操作空间：对于每次询问我们都可以将 $l$ 指针移动 $\sqrt{n}$ 次，而不改变时间复杂度。</p><p>每个块内右指针都是增加操作，左指针暴力计算即可。这样就只有增加操作了。</p><p>对于 $l$ 和 $r$ 在一个块内的，需要直接暴力计算。</p><h2 id="树上莫队"><a href="#树上莫队" class="headerlink" title="树上莫队"></a>树上莫队</h2><p>将树拍扁转化为序列问题。一般可处理子树问题（ dfs 序）、链问题（欧拉序）。</p><h4 id="1-WC2013-糖果公园"><a href="#1-WC2013-糖果公园" class="headerlink" title="1.[WC2013] 糖果公园"></a><a href="https://www.luogu.com.cn/problem/P4074">1.[WC2013] 糖果公园</a></h4><p>先求出欧拉序。对于 $(x,y)(dep[x]&lt;dep[y])$ 路径，分讨一下</p><ul><li><p>$lca = x$ 时，区间为 $[in_x,in_y]$。</p></li><li><p>$lca \ne x$ 时，区间为 $[out_x,in_y] \cup \{lca\}$。</p></li></ul><p>出现两次的点不计入答案，可以用异或实现。</p><h4 id="2-Ynoi2016-这是我自己的发明"><a href="#2-Ynoi2016-这是我自己的发明" class="headerlink" title="2.[Ynoi2016] 这是我自己的发明"></a><a href="https://www.luogu.com.cn/problem/P4689">2.[Ynoi2016] 这是我自己的发明</a></h4><p>先求出 dfs 序，可以转化为区间查询（对于换根，分讨一下）。</p><p>差分一下，可以转化为双关键点问题，使用莫队求解。</p><p>但这样最多每次有 16 个查询</p><p>发现形如 $[1,x] \cup [y,n]$ 的询问可以拆为 $[1,n]-[x+1,y-1]$，有关 $[1,n]$ 的可以预处理一下</p><p>具体地，以 $[1,x] \cup [y,n] \times [1,x’] \cup [y’,n]$ 为例</p><p>对某一颜色，它的贡献即为</p><script type="math/tex; mode=display">(cnt_{[1,n]}-cnt_{[x+1,y-1]})*(cnt_{[1,n]}-cnt_{[x'+1,y'-1]}) \\=cnt_{[1,n]} \times cnt_{[1,n]}-cnt_{[1,n]} \times (cnt_{[x+1,y-1]}+cnt_{[x'+1,y'-1]})+cnt_{[x+1,y-1]} \times cnt_{x'+1,y'-1}</script><p>左一预处理一下。左二是一维问题，排序求解。右一用莫队解。</p><p>这样每个询问只需拆成 4 个查询，可过。</p><h2 id="莫队二次离线"><a href="#莫队二次离线" class="headerlink" title="莫队二次离线"></a>莫队二次离线</h2><p>。。。</p><h2 id="杂题"><a href="#杂题" class="headerlink" title="杂题"></a>杂题</h2><h4 id="1-permu"><a href="#1-permu" class="headerlink" title="1.permu"></a><a href="https://hydro.ac/d/bzoj/p/4358">1.permu</a></h4><p>一个排列，一堆询问，求区间最长值域连续段，可离线</p><p>对于区间询问，考虑莫队。将存在的数看作 $1$，查询即为最长的连续 $1$。</p><p>每次需要将 $0$ 变 $1$ 和将 $1$ 变 $0$，或只需要其中一个并支持撤销。</p><p>明显要用并查集，变 $0$ 为 $1$ 是好做的，撤销用可撤销并查集即可。</p><p>按深度合并，答案为最大 $siz$，每次合并时记录一下即可。</p><p>初始时每个点都为 $0$，可以记一个 $vis$ 记录每个节点是否为 $1$，当合并时特判一下。</p><p>时间复杂度 $O(n\sqrt n\log n)$。</p><p>也可以观察最长连续 $1$ 性质。当加入 $x$ 时，更新 $x$ 点与当前段左右端点，因为中间不会再加数，不比 $x$ 点更优。</p><p><a href="https://www.luogu.com.cn/paste/ubj5vw0y">code</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/WAMonster/p/10118934.html">莫队算法——从入门到黑题</a></p><p><a href="https://www.luogu.com.cn/article/psut3omr">莫队二次离线</a></p>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CF1558E Down Below</title>
      <link href="/solutions/CF1558E/"/>
      <url>/solutions/CF1558E/</url>
      
        <content type="html"><![CDATA[<p>二分答案转化为判定性问题。</p><p>若没有不能回头走的限制，那么可以维护所有已经经过的点，选择 $a$ 最小的邻点扩展。</p><p>加上限制后我们仍维护已经遍历到的节点，记节点集合为 $S$，此时力量值为 $初值+\sum_{i \in S} b_i$，考虑怎样进行扩展。</p><ul><li><p>存在合法路径 $x \to p_1 \to p_2 \to … \to p_k \to y$ 满足 $x,y \in S,p_i \notin S$。</p></li><li><p>存在合法路径 $x \to p_1 \to p_2 \to … \to p_1 \to x$ 满足 $x \in S,p_i \notin S$，即一段重复路径和环。</p></li></ul><p>对于第一种路径，dfs 查找即可。对于第二种路径，发现其可以被拆为两条同起点的合法路径 $x \to p_1 \to … $,$x \to p’_1 \to p’_2 \to …$，且同起点的两条合法路径一定可以合成第二种路径。每次扩展一条即可，另一条会在之后被扩展。</p><p>时间复杂度 $O(nm\log V)$。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> U(x) ((int)x.size()) </span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e3</span><span class="number">+100</span>,INF=<span class="number">1e18</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> gc getchar()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rd read()</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> x=<span class="number">0</span>,f=<span class="number">0</span>; <span class="type">char</span> c=gc;</span><br><span class="line"><span class="keyword">for</span>(;c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>;c=gc) f|=(c==<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span>(;c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>;c=gc) x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(c^<span class="number">48</span>);</span><br><span class="line"><span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,a[N],b[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; G[N],vc;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> pre[N],vis[N],cur;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fu,<span class="type">int</span> w)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(cur) <span class="keyword">return</span>; <span class="keyword">if</span>(pre[u]) <span class="keyword">return</span> cur=u,<span class="built_in">void</span>(); pre[u]=fu;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> v:G[u])&#123;</span><br><span class="line"><span class="keyword">if</span>(a[v]&gt;=w||v==fu) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(vis[v]) <span class="keyword">return</span> cur=u,<span class="built_in">void</span>();</span><br><span class="line"><span class="built_in">dfs</span>(v,u,w+b[v]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">chk</span><span class="params">(<span class="type">int</span> mid)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i) pre[i]=vis[i]=<span class="number">0</span>;</span><br><span class="line">vis[<span class="number">1</span>]=<span class="number">1</span>,vc=&#123;<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">U</span>(vc)&lt;n)&#123;</span><br><span class="line">cur=<span class="number">0</span>; <span class="keyword">for</span>(<span class="type">int</span> u:vc) <span class="keyword">for</span>(<span class="type">int</span> v:G[u]) <span class="keyword">if</span>(a[v]&lt;mid&amp;&amp;!vis[v]) <span class="built_in">dfs</span>(v,u,mid+b[v]);</span><br><span class="line"><span class="keyword">if</span>(!cur) <span class="keyword">break</span>; <span class="keyword">for</span>(;!vis[cur];cur=pre[cur]) vc.<span class="built_in">pb</span>(cur),mid+=b[cur],vis[cur]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i) pre[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">U</span>(vc)==n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">n=rd,m=rd;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;++i) a[i]=rd;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;++i) b[i]=rd;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,x,y;i&lt;=m;++i) G[x=rd].<span class="built_in">pb</span>(y=rd),G[y].<span class="built_in">pb</span>(x);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> l=<span class="number">0</span>,r=INF;</span><br><span class="line"><span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line"><span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">chk</span>(mid)) r=mid;</span><br><span class="line"><span class="keyword">else</span> l=mid<span class="number">+1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, l);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i) G[i]=&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> T=rd;</span><br><span class="line"><span class="keyword">while</span>(T--) <span class="built_in">solve</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> solutions </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>左偏树</title>
      <link href="/notes/%E5%B7%A6%E5%81%8F%E6%A0%91/"/>
      <url>/notes/%E5%B7%A6%E5%81%8F%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>二叉堆额外维护一个 $dis$，表示到空节点的最短长度，保证 $dis_{lc} &gt; dis_{rc}$ 即可保证根节点的 $dis$ 为 $O(\log n)$。</p><p>合并时跳右儿子即可，时间复杂度 $O(\log n)$。</p><p><a href="https://www.luogu.com.cn/problem/P3377">1.【模板】左偏树/可并堆</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+100</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> gc getchar()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rd read()</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> x=<span class="number">0</span>,f=<span class="number">0</span>; <span class="type">char</span> c=gc;</span><br><span class="line"><span class="keyword">for</span>(;c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>;c=gc) f|=(c==<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span>(;c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>;c=gc) x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(c^<span class="number">48</span>);</span><br><span class="line"><span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,a[N];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lc(x) (t[x].ls)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rc(x) (t[x].rs)</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TREE</span>&#123; <span class="type">int</span> ls,rs,dis,fa,v; &#125;t[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123; <span class="keyword">return</span> t[x].fa==x?x:t[x].fa=<span class="built_in">find</span>(t[x].fa); &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mer</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!x||!y) <span class="keyword">return</span> x^y;</span><br><span class="line"><span class="keyword">if</span>(t[x].v&gt;t[y].v||(t[x].v==t[y].v&amp;&amp;x&gt;y)) <span class="built_in">swap</span>(x,y);</span><br><span class="line"><span class="built_in">rc</span>(x)=<span class="built_in">mer</span>(<span class="built_in">rc</span>(x),y);</span><br><span class="line"><span class="keyword">if</span>(t[<span class="built_in">lc</span>(x)].dis&lt;t[<span class="built_in">rc</span>(x)].dis) <span class="built_in">swap</span>(<span class="built_in">lc</span>(x),<span class="built_in">rc</span>(x));</span><br><span class="line">t[x].dis=t[<span class="built_in">rc</span>(x)].dis<span class="number">+1</span>,t[<span class="built_in">lc</span>(x)].fa=t[<span class="built_in">rc</span>(x)].fa=x;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> x)</span></span>&#123; t[x].v=<span class="number">-1</span>,t[<span class="built_in">lc</span>(x)].fa=<span class="built_in">lc</span>(x),t[<span class="built_in">rc</span>(x)].fa=<span class="built_in">rc</span>(x),t[x].fa=<span class="built_in">mer</span>(<span class="built_in">lc</span>(x),<span class="built_in">rc</span>(x)); &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> lc(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> rc(x)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">n=rd,m=rd;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i) t[i]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,i,rd&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,op,x,y;i&lt;=m;++i)&#123;</span><br><span class="line">op=rd,x=rd; <span class="keyword">if</span>(op==<span class="number">1</span>) y=rd;</span><br><span class="line"><span class="keyword">if</span>(op==<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(t[x].v==<span class="number">-1</span>||t[y].v==<span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">x=<span class="built_in">find</span>(x),y=<span class="built_in">find</span>(y);</span><br><span class="line"><span class="keyword">if</span>(x!=y) t[x].fa=t[y].fa=<span class="built_in">mer</span>(x,y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(t[x].v==<span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> x=<span class="built_in">find</span>(x),<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, t[x].v),<span class="built_in">del</span>(x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="【模板】k-短路-SDOI2010-魔法猪学院"><a href="#【模板】k-短路-SDOI2010-魔法猪学院" class="headerlink" title="【模板】k 短路 / [SDOI2010] 魔法猪学院"></a><a href="https://www.luogu.com.cn/problem/P2483">【模板】k 短路 / [SDOI2010] 魔法猪学院</a></h2><p>最优策略是，每次找到一条未考虑的最短路径。</p><p>以 $n$ 为根建出反图的最短路树。</p><p>对于不在树上的边 $e: (u \to v,w)$，记 $\delta(e) = dis_v+w-dis_u$。</p><p>对于一条 $1 \to n$ 路径，记 $S$ 为路径上不在最短树上的边的集合，那么路径长度为 $dis_1 + \sum_{e \in S} \delta(e)$。</p><p>$dis_1$ 是定值，只需求出后面的未出现的最小值即可。</p><p>将边的顺序钦定好，此时边的集合唯一对应一条 $1 \to n$ 的路径。</p><p>考虑动态加边，那么每次会将最后一条边换掉，或者加一条新边。</p><p>考虑对每个点维护一个边集，存以其到 $n$ 链上为起点的非树边。</p><p>用堆维护，每次相当于向下移动一步。</p><p>初始化时需要继承之前的信息，用可持久化堆。</p><p>时间复杂度 $O(n\log n+m\log m+V\log V)$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> db=<span class="type">double</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pid pair<span class="string">&lt;int,db&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> U(x) ((int)x.size())</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e4</span><span class="number">+100</span>,M=<span class="number">2e5</span><span class="number">+100</span>;</span><br><span class="line"><span class="type">const</span> db INF=<span class="number">1e15</span>,eps=<span class="number">1e-8</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">sgn</span><span class="params">(db x)</span></span>&#123; <span class="keyword">return</span> (x&gt;eps)-(x&lt;-eps); &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">chkmin</span><span class="params">(db &amp;x,db y)</span></span>&#123; <span class="keyword">return</span> <span class="built_in">sgn</span>(y-x)&lt;<span class="number">0</span>?x=y,<span class="number">1</span>:<span class="number">0</span>; &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> gc getchar()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rd read()</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> x=<span class="number">0</span>,f=<span class="number">0</span>; <span class="type">char</span> c=gc;</span><br><span class="line"><span class="keyword">for</span>(;c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>;c=gc) f|=(c==<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span>(;c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>;c=gc) x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(c^<span class="number">48</span>);</span><br><span class="line"><span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,fa[N],pre[M]; db E;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ADJ</span>&#123; <span class="type">int</span> v; db w; <span class="type">int</span> i; &#125;;</span><br><span class="line">vector&lt;ADJ&gt; G[N],R[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp</span>&#123; <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> pid &amp;x,<span class="type">const</span> pid &amp;y)</span></span>&#123; <span class="keyword">return</span> <span class="built_in">sgn</span>(x.se-y.se)&gt;<span class="number">0</span>; &#125; &#125;;</span><br><span class="line">priority_queue&lt;pid,vector&lt;pid&gt;,cmp&gt; q; <span class="type">int</span> vis[N]; db dis[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dij</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i) vis[i]=<span class="number">0</span>,dis[i]=INF; q.<span class="built_in">push</span>(&#123;n,dis[n]=<span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> u=q.<span class="built_in">top</span>().fi; q.<span class="built_in">pop</span>(); <span class="keyword">if</span>(vis[u]) <span class="keyword">continue</span>; vis[u]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> [v,w,i]:R[u]) <span class="keyword">if</span>(<span class="built_in">chkmin</span>(dis[v],dis[u]+w)) fa[v]=u,pre[v]=i,q.<span class="built_in">push</span>(&#123;v,dis[v]&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> HEAP&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lc(x) (t[(x)].ls)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rc(x) (t[(x)].rs)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> v(x) (t[(x)].v)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> dis(x) (t[(x)].dis)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> to(x) (t[(x)].to)</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">TREE</span>&#123; <span class="type">int</span> ls,rs,dis,to; db v; &#125;t[N&lt;&lt;<span class="number">5</span>]; <span class="type">int</span> tot=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">make</span><span class="params">(<span class="type">int</span> to,db v)</span></span>&#123; <span class="keyword">return</span> t[++tot]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,to,v&#125;,tot; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">clone</span><span class="params">(<span class="type">int</span> x)</span></span>&#123; <span class="keyword">return</span> t[++tot]=t[x],tot; &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">mer</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!x||!y) <span class="keyword">return</span> x^y;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">v</span>(x)&gt;<span class="built_in">v</span>(y)) <span class="built_in">swap</span>(x,y);</span><br><span class="line"><span class="type">int</span> z=<span class="built_in">clone</span>(x); <span class="built_in">rc</span>(z)=<span class="built_in">mer</span>(<span class="built_in">rc</span>(z),y);</span><br><span class="line"><span class="keyword">if</span>(t[<span class="built_in">lc</span>(z)].dis&lt;(t[<span class="built_in">rc</span>(z)].dis)) <span class="built_in">swap</span>(<span class="built_in">lc</span>(z),<span class="built_in">rc</span>(z));</span><br><span class="line"><span class="built_in">dis</span>(z)=(t[<span class="built_in">rc</span>(z)].dis)<span class="number">+1</span>; <span class="keyword">return</span> z;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> rt[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> HEAP;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i) q.<span class="built_in">push</span>(&#123;i,dis[i]&#125;);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> u=q.<span class="built_in">top</span>().fi; q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> [v,w,i]:G[u]) <span class="keyword">if</span>(pre[u]!=i) rt[u]=<span class="built_in">mer</span>(rt[u],<span class="built_in">make</span>(v,dis[v]-dis[u]+w));</span><br><span class="line">        rt[u]=<span class="built_in">mer</span>(rt[u],rt[fa[u]]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">calc</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> HEAP;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">sgn</span>(dis[<span class="number">1</span>]-E)&gt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    E-=dis[<span class="number">1</span>]; <span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(!rt[<span class="number">1</span>]) <span class="keyword">return</span> res;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;rt[<span class="number">1</span>],<span class="built_in">v</span>(rt[<span class="number">1</span>])&#125;);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">    <span class="keyword">auto</span> [u,d]=q.<span class="built_in">top</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">sgn</span>(dis[<span class="number">1</span>]+d-E)&gt;<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    E-=dis[<span class="number">1</span>]+d,++res;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">lc</span>(u)) q.<span class="built_in">push</span>(&#123;<span class="built_in">lc</span>(u),d-<span class="built_in">v</span>(u)+<span class="built_in">v</span>(<span class="built_in">lc</span>(u))&#125;);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">rc</span>(u)) q.<span class="built_in">push</span>(&#123;<span class="built_in">rc</span>(u),d-<span class="built_in">v</span>(u)+<span class="built_in">v</span>(<span class="built_in">rc</span>(u))&#125;);</span><br><span class="line">    <span class="keyword">if</span>(rt[<span class="built_in">to</span>(u)]) q.<span class="built_in">push</span>(&#123;rt[<span class="built_in">to</span>(u)],d+<span class="built_in">v</span>(rt[<span class="built_in">to</span>(u)])&#125;);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">n=rd,m=rd,<span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;E);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,u,v;i&lt;=m;++i)&#123;</span><br><span class="line">        u=rd,v=rd; db w; <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;w);</span><br><span class="line">        <span class="keyword">if</span>(u==n) <span class="keyword">continue</span>;</span><br><span class="line">        G[u].<span class="built_in">pb</span>(&#123;v,w,i&#125;),R[v].<span class="built_in">pb</span>(&#123;u,w,i&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> u=<span class="number">1</span>;u&lt;=n;++u) <span class="built_in">reverse</span>(G[u].<span class="built_in">begin</span>(),G[u].<span class="built_in">end</span>()),<span class="built_in">reverse</span>(R[u].<span class="built_in">begin</span>(),R[u].<span class="built_in">end</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dij</span>(),<span class="built_in">init</span>();</span><br><span class="line">    </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">calc</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.luogu.com.cn/article/uoeyv3gq">可合并堆</a></p><p><a href="https://www.cnblogs.com/-Wallace-/p/kth-path.html">k 短路</a></p>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>根号分治</title>
      <link href="/notes/%E6%A0%B9%E5%8F%B7%E5%88%86%E6%B2%BB/"/>
      <url>/notes/%E6%A0%B9%E5%8F%B7%E5%88%86%E6%B2%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h4 id="1-Remainder-Problem"><a href="#1-Remainder-Problem" class="headerlink" title="1.Remainder Problem"></a><a href="https://www.luogu.com.cn/problem/CF1207F">1.Remainder Problem</a></h4><p>两种暴力</p><ul><li><p>按题意模拟，修改时间复杂度 $O(1)$，查询时间复杂度 $O(n)$。</p></li><li><p>维护一个 $b$ 数组，$b_{ij}$ 表示所有模 $i$ 得 $j$ 的下标的数之和，修改时间复杂度 $O(n)$，查询时间复杂度 $O(1)$。</p></li></ul><p>两种暴力时间复杂度极不平衡。考虑设计一个阈值 $B$，将询问分成两块，分别处理。对于 $\le B$ 的，用法二。对于大于 $B$ 的，用法一。</p><p>取 $B=\sqrt n$，时间复杂度 $O(q\sqrt n)$。</p><p><a href="https://www.luogu.com.cn/paste/4ufgboau">code</a></p><p>由于数据问题，块长取理论最优块长不一定最优。</p><h4 id="2-Two-Arithmetic-Progressions"><a href="#2-Two-Arithmetic-Progressions" class="headerlink" title="2.Two Arithmetic Progressions"></a><a href="https://www.luogu.com.cn/problem/CF710D">2.Two Arithmetic Progressions</a></h4><p>不妨设 $a_1&gt;=a_2$。有两种暴力</p><ul><li><p>枚举。时间复杂度 $O(\frac{n}{a_1})$。</p></li><li><p>循环节大小为 $lcm(a_1,a_2)$，找到第一个重复的位置 $x$，答案即为 $\left\lfloor \frac{R-x}{lcm(a_1,a_2)}\right\rfloor +1$。时间复杂度 $O(\frac{lcm(a_1,a_2)}{a_1})$。</p></li></ul><p>将两个暴力拼一起，记 $B=\sqrt{2 \times 10^9} \approx 44722$。小于或等于 $\le B$ 的用法二，否则用法一。</p><p><a href="https://www.luogu.com.cn/paste/ekx6s5k3">code</a></p><h4 id="3-IOI2009-Regions"><a href="#3-IOI2009-Regions" class="headerlink" title="3.[IOI2009] Regions"></a><a href="https://www.luogu.com.cn/problem/P5901">3.[IOI2009] Regions</a></h4><p>点染色很显然可以根号分治，然后就 $O(n\sqrt{n})$ 了。</p><p>对于都为小颜色的，我使用了虚树求解。需要大力卡常，包括但不限于</p><ul><li><p>用 dfs 序求 lca。</p></li><li><p>按 dfs 序排序时用归并排序。</p></li><li><p>限制大颜色的数量，将每个颜色对应的点的个数求出，取第 $k$ 大为阈值。</p></li><li><p>邻接表换为链式前向星。</p></li></ul><p><a href="https://www.luogu.com.cn/paste/d3n55f9l">code</a></p><h4 id="4-ARC052D-9"><a href="#4-ARC052D-9" class="headerlink" title="4.[ARC052D] 9"></a><a href="https://www.luogu.com.cn/problem/AT_arc052_d">4.[ARC052D] 9</a></h4><p>数位之和最大为 $90$。对 $K$ 分讨</p><ul><li><p>$K \le \sqrt{M}$，直接枚举。</p></li><li><p>$K \le \sqrt{M}$，数位 DP。</p></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.luogu.com.cn/article/5gtqzd4a">根号分治</a></p>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>毛毛虫剖分</title>
      <link href="/notes/%E6%AF%9B%E6%AF%9B%E8%99%AB%E5%89%96%E5%88%86/"/>
      <url>/notes/%E6%AF%9B%E6%AF%9B%E8%99%AB%E5%89%96%E5%88%86/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>一种树的重标号方式。</p><p>先对树进行重剖。对树进行 dfs，当遍历到 $u$ 时</p><ul><li><p>若 $u$ 未被标号，对 $u$ 进行标号。</p></li><li><p>若 $u$ 为重链的的链头，遍历这条重链，对相邻非重链上的节点依次标号</p></li><li><p>若 $u$ 有重儿子，遍历重儿子。</p></li><li><p>遍历非重儿子。</p></li></ul><p>这样标号满足</p><ul><li><p>一条重链除链头外标号连续。</p></li><li><p>一条重链的邻点标号连续。</p></li><li><p>子树标号为两段不相交的连续区间。</p></li></ul><p>那么链、子树、链的邻点的信息都可以维护了。</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h4 id="1-NOI2021-轻重边"><a href="#1-NOI2021-轻重边" class="headerlink" title="1.[NOI2021] 轻重边"></a><a href="https://www.luogu.com.cn/problem/P7735">1.[NOI2021] 轻重边</a></h4><h4 id="2-「GLR-R3」谷雨"><a href="#2-「GLR-R3」谷雨" class="headerlink" title="2.「GLR-R3」谷雨"></a><a href="https://www.luogu.com.cn/problem/P8479">2.「GLR-R3」谷雨</a></h4><p>只需要维护毛毛虫的信息，所以可以对毛毛虫顺序标号。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/A-Quark/p/16435243.html">毛毛虫剖分</a></p>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>点分树</title>
      <link href="/notes/%E7%82%B9%E5%88%86%E6%A0%91/"/>
      <url>/notes/%E7%82%B9%E5%88%86%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>将点分治的过程离线下来，即将重心相连，可以形成一棵树，称作点分树。它有很好的性质</p><ul><li><p>树的深度为 $O(\log n)$。</p></li><li><p>所有点子树大小为 $O(n\log n)$。</p></li><li><p>点分树上 $lca(u,v)$ 一定在<strong>原树</strong> $u \leadsto v$ 上。</p></li></ul><p>对于任意点 $u$，一般会用数据结构维护 $u$ 的子树的对 $u$ 信息，$u$ 的子树对 $fa_u$ 的信息。后者用于容斥。</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h4 id="1-【模板】点分树-震波"><a href="#1-【模板】点分树-震波" class="headerlink" title="1.【模板】点分树 | 震波"></a><a href="https://www.luogu.com.cn/problem/P6329">1.【模板】点分树 | 震波</a></h4><p>建出点分树。对于查询，枚举 $x$ 在点分树上的祖先，统计祖先的子树对答案的贡献，将重复的容斥掉。对于修改，用树状数组维护信息，将 $x$ 在点分树上的祖先都改一下即可。时间复杂度 $O(n\log^2n)$。</p><p><a href="https://www.luogu.com.cn/paste/9s306omk">code</a></p><h4 id="2-HNOI2015-开店"><a href="#2-HNOI2015-开店" class="headerlink" title="2.[HNOI2015] 开店"></a><a href="https://www.luogu.com.cn/problem/P3241">2.[HNOI2015] 开店</a></h4><p>一棵树，点有点权，多次询问，每次询问点权 $&lt;=k$ 的点到 $u$ 的距离和，强制在线。</p><p>由于没有修改，对每个点开个 vector 按权值排序并预处理前缀和，查询时二分一下即可。</p><h4 id="3-ZJOI2015-幻想乡战略游戏"><a href="#3-ZJOI2015-幻想乡战略游戏" class="headerlink" title="3.[ZJOI2015] 幻想乡战略游戏"></a><a href="https://www.luogu.com.cn/problem/P3345">3.[ZJOI2015] 幻想乡战略游戏</a></h4><p>在点分树上每次向重心移动一步，最后到达重心，移动次数为 $O(\log n)$。</p><p>考虑重心确定时如何快速计算答案，类似换根 DP，每次跳父亲计算答案即可。</p><p>时间复杂度 $O(n\log^2n)$。</p><h4 id="4-小清新数据结构题"><a href="#4-小清新数据结构题" class="headerlink" title="4.小清新数据结构题"></a><a href="https://www.luogu.com.cn/problem/P3676">4.小清新数据结构题</a></h4><p>设根为 $1$，推式子得到</p><script type="math/tex; mode=display">ans = \sum_{i} siz_i^2 + siz_1(dep_u-1) - 2siz_{[u,1)}siz_1</script><p>其中 $siz{[u,1)}$ 为 $u \to 1$ 不包括 $1$ 的 $siz$ 和。树剖简单维护，时间复杂度 $O(n\log^2n)$。</p><p>但是现在在学点分树，考虑点分树做法。还是推式子，考虑将平方拆开。</p><script type="math/tex; mode=display">\begin{align}ans &= \sum_{i}siz_i^2 \\&= \sum_{x}\sum_{y} a_xa_yd_{lca(x,y)} \\&= \frac{1}{2}\sum_{x}\sum_{y} a_xa_y(d_x+d_y-dis(x,y)) \\&= (\sum_{x}a_xdis(x,u) + \sum_{x}a_x)(\sum_{x}a_x) + \frac{1}{2}\sum_{x}\sum_{y}a_xa_ydis(x,y)\end{align}</script><p>对于前面的，需要快速查询 $\sum_{x}a_xdis(x,u)$。</p><p>对于后面的，它和根没有关系，初始值是好求的，当 $a_u+v$ 时，它增加 $2v\sum_{x}a_xdis(x,u)$。</p><p>点分树，时间复杂度 $O(n\log n)$。</p><h4 id="5-Ynoi2011-成都七中"><a href="#5-Ynoi2011-成都七中" class="headerlink" title="5.[Ynoi2011] 成都七中"></a><a href="https://www.luogu.com.cn/problem/P5311">5.[Ynoi2011] 成都七中</a></h4><p>对于询问 $(l,r,u)$，可以将每个点到 $u$ 路径上的最大/小编号预处理出来，记为 $(x,y)$。</p><p>那么点 $(x,y)$ 与 $u$ 在同一个连通块当且仅当 $l \le x,y \le r$。扫一遍求解，时间复杂度 $O(mn)$。</p><p>只要 $u,v$ 在同一连通块中，那么 $(l,r,u)$ 与 $(l,r,v)$ 答案相同。</p><p>建出点分树，求出点分树上与 $u$ 在同一连通块的最浅点 $v$，此时询问变为 $(l,r,v)$，好处是点分树的子树和为 $O(n\log n)$。</p><p>对于 $v$ 的求解可以在点分树上暴力往上跳，用倍增维护路径最大/小编号，还可以预处理点分树上每个点到祖先节点路径的最大/小编号。</p><p>一个点会挂多个询问，离线树状数组求解，时间复杂度 $O(n\log^2n)$。</p><h4 id="6-Iqea"><a href="#6-Iqea" class="headerlink" title="6.Iqea"></a><a href="https://www.luogu.com.cn/problem/CF936E">6.Iqea</a></h4><p>保证剩余部分也连通。</p><p>考虑将极长行连通块缩成一个点，将相邻点连边，形成一棵树。</p><p>树上动态加点，求距离最小点，考虑点分树。</p><p>考虑如何通过中间点计算答案，需要计算某点到特定连通块的距离，用 bfs。</p><p>拆式子，需要对连通块每个点维护前后缀最小值。</p><h4 id="7-WC2014-紫荆花之恋"><a href="#7-WC2014-紫荆花之恋" class="headerlink" title="7.[WC2014] 紫荆花之恋"></a><a href="https://www.luogu.com.cn/problem/P3920">7.[WC2014] 紫荆花之恋</a></h4><p>需要每加入一个点时将与它相关的点对的数量求出来，再加入该点。</p><p>如果不强制在线，那么可以先建出点分树。需要支持加入，查询比 $v$ 小的数的个数。可以用平衡树。</p><p>还有一种根号分治的做法。维护两个 ‘vector’ A、B，在 $A$ 中暴力加入点 $v$，若 $|A| &gt; S$ 那么对 A,B 进行归并排序，将 A 清空。查询时在 A,B 中二分即可。</p><p>由于强制在线，考虑设计一个平衡因子 $\alpha$，若存在 $siz_u &gt; \alpha siz_{fa_u}$，那么将 $fa_u$ 的子树重构，这样来维持点分树的高度为 $O(\log n)$。取 $\alpha=0.9$ 较优。</p><p>取 $S=\sqrt{n}$ 可以做到 $O(n\sqrt{n}\log n)$。</p><p>实现上一堆细节，具体看代码。</p><p><a href="https://www.luogu.com.cn/paste/84yw15yw">code</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.luogu.com.cn/article/bscuomom">点分树</a></p><p><a href="https://www.luogu.com.cn/training/78277">ffffyc 的点分树学习题单</a></p>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>分块</title>
      <link href="/notes/block/"/>
      <url>/notes/block/</url>
      
        <content type="html"><![CDATA[<h2 id="分块写法"><a href="#分块写法" class="headerlink" title="分块写法"></a>分块写法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> st(i) ((i-1)*len+1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ed(i) min(i*len,n)</span></span><br><span class="line">len=...; <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) bk[i]=(i<span class="number">-1</span>)/len<span class="number">+1</span>;</span><br></pre></td></tr></table></figure><p>块的编号：$1$ 到 $bk[n]$。</p><h2 id="序列分块"><a href="#序列分块" class="headerlink" title="序列分块"></a>序列分块</h2><h3 id="1-数列分块入门1-9"><a href="#1-数列分块入门1-9" class="headerlink" title="1.数列分块入门1-9"></a><a href="https://loj.ac/p?keyword=%E5%88%86%E5%9D%97">1.数列分块入门1-9</a></h3><h4 id="4"><a href="#4" class="headerlink" title="4"></a>4</h4><p>区间加法，区间求和。</p><p>懒标记。<br>时间复杂度 $O(m\sqrt{n})$。</p><p>可以树状数组/线段树。</p><h4 id="2"><a href="#2" class="headerlink" title="2"></a>2</h4><p>区间加法，询问区间 $\le x$ 的元素个数。</p><p>块内排序，查询时二分。<br>时间复杂度 $O(m\sqrt{n}\log n)$。<br>归并排序+条块长可以做到 $O(m\sqrt{n\log n})$。</p><h4 id="6"><a href="#6" class="headerlink" title="6"></a>6</h4><p>单点插入，单点询问。</p><p>定期重构。</p><p>可以平衡树。</p><h4 id="9"><a href="#9" class="headerlink" title="9"></a>9</h4><p>区间众数。</p><p>一段区间的众数可能是中间块内的众数或两边散块的众数。</p><p>可以回滚莫队。</p><p><a href="/notes/数列分块入门">code</a></p><h4 id="2-HNOI2010-弹飞绵羊"><a href="#2-HNOI2010-弹飞绵羊" class="headerlink" title="2.[HNOI2010] 弹飞绵羊"></a><a href="https://www.luogu.com.cn/problem/P3203">2.[HNOI2010] 弹飞绵羊</a></h4><p>每个块预处理每个元素走出本块需要的步数和到达的点。</p><h4 id="3-简单的数列题"><a href="#3-简单的数列题" class="headerlink" title="3.简单的数列题"></a><a href="https://loj.ac/p/6546">3.简单的数列题</a></h4><p>块内维护下凸壳。</p><h4 id="4-作诗"><a href="#4-作诗" class="headerlink" title="4.作诗"></a><a href="https://www.luogu.com.cn/problem/P4135">4.作诗</a></h4><p>维护前缀和，散块暴力判断。时间复杂度 $O(m\sqrt{n})$。</p><h4 id="5-Ynoi2019-模拟赛-Yuno-loves-sqrt-technology-III"><a href="#5-Ynoi2019-模拟赛-Yuno-loves-sqrt-technology-III" class="headerlink" title="5.[Ynoi2019 模拟赛] Yuno loves sqrt technology III"></a><a href="https://www.luogu.com.cn/problem/P5048">5.[Ynoi2019 模拟赛] Yuno loves sqrt technology III</a></h4><p>需要判断一个数在区间中出现次数是否 $&gt; k$，记录所有同类数的位置，判断即可。</p><h4 id="6-Ynoi2019-模拟赛-Yuno-loves-sqrt-technology-I"><a href="#6-Ynoi2019-模拟赛-Yuno-loves-sqrt-technology-I" class="headerlink" title="6.[Ynoi2019 模拟赛] Yuno loves sqrt technology I"></a><a href="https://www.luogu.com.cn/problem/P5046">6.[Ynoi2019 模拟赛] Yuno loves sqrt technology I</a></h4><p>归并。</p><h4 id="7-Chef-and-Churu"><a href="#7-Chef-and-Churu" class="headerlink" title="7.Chef and Churu"></a>7.Chef and Churu</h4><p>给你一个长为 $n$ 的序列和 $m$ 个区间，支持序列单点修改，查询范围区间和。</p><p>将区间分块，统计序列每个元素在每个块内的出现次数。块内的区间和可以简单维护。</p><p>对于散块，需要 $O(\sqrt{m})$ 次区间求和。对序列分块，维护序列前缀和。</p><h4 id="8-带插入区间K小值"><a href="#8-带插入区间K小值" class="headerlink" title="8.带插入区间K小值"></a><a href="https://www.luogu.com.cn/problem/P4278">8.带插入区间K小值</a></h4><p>aaa！！！</p><h2 id="树分块"><a href="#树分块" class="headerlink" title="树分块"></a>树分块</h2><h3 id="随机撒点"><a href="#随机撒点" class="headerlink" title="随机撒点"></a>随机撒点</h3><h4 id="1-Count-on-a-tree-II-【模板】树分块"><a href="#1-Count-on-a-tree-II-【模板】树分块" class="headerlink" title="1.Count on a tree II/【模板】树分块"></a><a href="https://www.luogu.com.cn/problem/P6177">1.Count on a tree II/【模板】树分块</a></h4><h3 id="王室联邦分块"><a href="#王室联邦分块" class="headerlink" title="王室联邦分块"></a>王室联邦分块</h3><h4 id="1-SCOI2005-王室联邦"><a href="#1-SCOI2005-王室联邦" class="headerlink" title="1.[SCOI2005] 王室联邦"></a><a href="https://www.luogu.com.cn/problem/P2325">1.[SCOI2005] 王室联邦</a></h4><h3 id="基于-top-cluster-的树分块"><a href="#基于-top-cluster-的树分块" class="headerlink" title="基于 top cluster 的树分块"></a>基于 top cluster 的树分块</h3><p>。。。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.luogu.com/article/funv5guk">分块</a></p><p><a href="https://www.cnblogs.com/IzayoiMiku/p/14691521.html">树分块</a></p>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>DLX</title>
      <link href="/notes/DLX/"/>
      <url>/notes/DLX/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>神秘的搜索优化？</p><p><a href="https://www.luogu.com.cn/problem/P4929">【模板】舞蹈链（DLX）</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">500</span><span class="number">+10</span>,M=<span class="number">6e3</span><span class="number">+100</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> gc getchar()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rd read()</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> x=<span class="number">0</span>,f=<span class="number">0</span>; <span class="type">char</span> c=gc;</span><br><span class="line"><span class="keyword">for</span>(;c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>;c=gc) f|=(c==<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span>(;c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>;c=gc) x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(c^<span class="number">48</span>);</span><br><span class="line"><span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,a[N][N],col[M],cow[M],siz[N],head[N],U[M],D[M],L[M],R[M],tot=<span class="number">0</span>,sta[N],tp=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bui</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span>&#123; <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=m;++i) L[i]=(i==<span class="number">0</span>?m:i<span class="number">-1</span>),R[i]=(i==m?<span class="number">0</span>:i<span class="number">+1</span>),U[i]=D[i]=i; tot=m; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ins</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">D[++tot]=D[y],U[tot]=y,U[D[y]]=tot,D[y]=tot,cow[tot]=x,++siz[col[tot]=y];</span><br><span class="line"><span class="keyword">if</span>(!head[x]) head[x]=L[tot]=R[tot]=tot;</span><br><span class="line"><span class="keyword">else</span> R[tot]=R[head[x]],L[tot]=head[x],L[R[head[x]]]=tot,R[head[x]]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">R[L[c]]=R[c],L[R[c]]=L[c];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=D[c];i!=c;i=D[i])</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=R[i];j!=i;j=R[j])</span><br><span class="line">U[D[j]]=U[j],D[U[j]]=D[j],--siz[col[j]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rev</span><span class="params">(<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">R[L[c]]=L[R[c]]=c;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=U[c];i!=c;i=U[i])</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=L[i];j!=i;j=L[j])</span><br><span class="line">U[D[j]]=D[U[j]]=j,++siz[col[j]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dance</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!R[<span class="number">0</span>]) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> c=R[<span class="number">0</span>]; <span class="keyword">for</span>(<span class="type">int</span> i=R[<span class="number">0</span>];i!=<span class="number">0</span>;i=R[i]) <span class="keyword">if</span>(siz[i]&lt;siz[c]) c=i;</span><br><span class="line"><span class="built_in">del</span>(c);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=D[c];i!=c;i=D[i])&#123;</span><br><span class="line">sta[++tp]=cow[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=R[i];j!=i;j=R[j]) <span class="built_in">del</span>(col[j]);</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">dance</span>()) <span class="keyword">return</span> <span class="number">1</span>; --tp;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=L[i];j!=i;j=L[j]) <span class="built_in">rev</span>(col[j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">rev</span>(c);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">n=rd,m=rd,<span class="built_in">bui</span>(n,m);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;++j)</span><br><span class="line"><span class="keyword">if</span>(rd) <span class="built_in">ins</span>(i,j);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!<span class="built_in">dance</span>()) <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;No Solution!\n&quot;</span>),<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=tp;++i) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, sta[i]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h4 id="1-数独"><a href="#1-数独" class="headerlink" title="1.数独"></a><a href="https://www.luogu.com.cn/problem/P1784">1.数独</a></h4><p>$(x,y,z)$ 三元组，表示 $(x,y)$ 填 $z$。那么限制有</p><ul><li><p>每行数不重复</p></li><li><p>每列数不重复</p></li><li><p>每宫数不重复</p></li><li><p>每格数不重复</p></li></ul><p>有 $9^3=729$ 个三元组，限制需要 $4 \times 9^2=324$ 位，总共有 $3 \times 729=2187$ 个 $1$。</p><h4 id="2-NOIP2009-提高组-靶形数独"><a href="#2-NOIP2009-提高组-靶形数独" class="headerlink" title="2.[NOIP2009 提高组] 靶形数独"></a><a href="https://www.luogu.com.cn/problem/P1074">2.[NOIP2009 提高组] 靶形数独</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> val[<span class="number">10</span>][<span class="number">10</span>]=&#123;</span><br><span class="line">&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="number">0</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>&#125;,</span><br><span class="line">&#123;<span class="number">0</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">6</span>&#125;,</span><br><span class="line">&#123;<span class="number">0</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>&#125;,</span><br><span class="line">&#123;<span class="number">0</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">9</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>&#125;,</span><br><span class="line">&#123;<span class="number">0</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>&#125;,</span><br><span class="line">&#123;<span class="number">0</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">9</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>&#125;,</span><br><span class="line">&#123;<span class="number">0</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>&#125;,</span><br><span class="line">&#123;<span class="number">0</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">6</span>&#125;,</span><br><span class="line">&#123;<span class="number">0</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="3-NOI2005-智慧珠游戏"><a href="#3-NOI2005-智慧珠游戏" class="headerlink" title="3.[NOI2005] 智慧珠游戏"></a><a href="https://www.luogu.com.cn/problem/P4205">3.[NOI2005] 智慧珠游戏</a></h4><p>用五元组表示一次操作，即类型，位置，旋转次数，是否翻转。<br>限制是</p><ul><li><p>位置被占</p></li><li><p>珠子被占</p></li></ul><p>最终所有位置与珠子都要被占。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.luogu.com.cn/article/rjhni32v">DLX</a></p>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>条带状矩阵的消元</title>
      <link href="/notes/band_matrix/"/>
      <url>/notes/band_matrix/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>高斯消元的时间复杂度为 $O(n^3)$。</p><p>对于条带状矩阵，即满足对于任意 $i$，从 $(i,i)$ 向右拓展有不超过 $d-1$ 个数字，向下拓展有不超过 $d-1$ 个数字的矩阵。可以做到 $O(nd^2)$。</p><p>实现是简单的，类似高斯消元，限制范围即可。需要注意的是，当主元为 $0$ 时需要换行，那么消元时需要向右消 $2d$ 个位置。</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h4 id="1-Broken-robot"><a href="#1-Broken-robot" class="headerlink" title="1.Broken robot"></a><a href="https://www.luogu.com.cn/problem/CF24D">1.Broken robot</a></h4><h4 id="2-六省联考-2017-分手是祝愿"><a href="#2-六省联考-2017-分手是祝愿" class="headerlink" title="2.[六省联考 2017] 分手是祝愿"></a><a href="https://www.luogu.com.cn/problem/P3750">2.[六省联考 2017] 分手是祝愿</a></h4><h4 id="3-Circles-of-Waiting"><a href="#3-Circles-of-Waiting" class="headerlink" title="3.Circles of Waiting"></a><a href="https://www.luogu.com.cn/problem/CF963E">3.Circles of Waiting</a></h4><p>DP，只有 $x^2+y^2 \le R^2$ 的不为 $0$，有 $O(R^2)$ 个点。</p><p>连续标号，那么是一个满足 $d=R+1$ 的矩阵，消元时间复杂度 $O(R^4)$。</p><h4 id="4-BJOI2018-治疗之雨"><a href="#4-BJOI2018-治疗之雨" class="headerlink" title="4.[BJOI2018] 治疗之雨"></a><a href="https://www.luogu.com.cn/problem/P4457">4.[BJOI2018] 治疗之雨</a></h4><p>矩阵是下三角的，反着消变为上三角的，时间复杂度 $O(n^2d)$。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.luogu.com.cn/article/3zspg7qj">浅谈高斯消元拓展之 band-matrix</a></p>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>最短路树</title>
      <link href="/notes/%E6%9C%80%E7%9F%AD%E8%B7%AF%E6%A0%91/"/>
      <url>/notes/%E6%9C%80%E7%9F%AD%E8%B7%AF%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>原图的一棵生成树，满足每个点到源点的最短路长度等于生成树中每个点到根节点的距离。</p><p>在 dij 过程中找每个点的前驱即可。</p><p>将所有满足 $dis_v=dis_u+w$ 的边 $(u \to v)$ 加入，得到最短路 DAG，最短路 DAG 的生成树为最短路树。</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h4 id="1-Paths-and-Trees"><a href="#1-Paths-and-Trees" class="headerlink" title="1.Paths and Trees"></a><a href="https://www.luogu.com.cn/problem/CF545E">1.Paths and Trees</a></h4><p>直接贪心。</p><h4 id="2-Edge-Deletion"><a href="#2-Edge-Deletion" class="headerlink" title="2.Edge Deletion"></a><a href="https://www.luogu.com.cn/problem/CF1076D">2.Edge Deletion</a></h4><p>。。。</p><h4 id="3-Berland-and-the-Shortest-Paths"><a href="#3-Berland-and-the-Shortest-Paths" class="headerlink" title="3.Berland and the Shortest Paths"></a><a href="https://www.luogu.com.cn/problem/CF1005F">3.Berland and the Shortest Paths</a></h4><p>每个点是独立的。。。</p><h4 id="4-删边最短路"><a href="#4-删边最短路" class="headerlink" title="4.删边最短路"></a>4.删边最短路</h4><p>给定一张 无向正权图，对图上的每条边，求删去该边后的最短路。</p><p>求出一条 $1 \to n$ 的最短路，记为 $P$，$T_1,T_n$ 表示以 $1,n$ 为源点的最短路树。<br>若 $e \notin P$，那么最短路不变。</p><p>否则最短路形如 $(1 \to u) + (u \to v) + (v \to n)$。</p><p><a href="https://www.luogu.com.cn/problem/CF1163F">Indecisive Taxi Fee</a></p><p>枚举每条边作为非最短路树上的边，其对 $P$ 的一段区间有贡献，离线扫描线即可。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.luogu.com.cn/article/86gevhsv">最短路树</a></p>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>线段树进阶</title>
      <link href="/notes/%E7%BA%BF%E6%AE%B5%E6%A0%91%E8%BF%9B%E9%98%B6/"/>
      <url>/notes/%E7%BA%BF%E6%AE%B5%E6%A0%91%E8%BF%9B%E9%98%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="板子"><a href="#板子" class="headerlink" title="板子"></a>板子</h2><h4 id="1-【模板】线段树-1"><a href="#1-【模板】线段树-1" class="headerlink" title="1.【模板】线段树 1"></a><a href="https://www.luogu.com.cn/problem/P3372">1.【模板】线段树 1</a></h4><p><a href="https://www.luogu.com.cn/paste/vwkwqr8x">code</a></p><h4 id="2-【模板】线段树-2"><a href="#2-【模板】线段树-2" class="headerlink" title="2.【模板】线段树 2"></a><a href="https://www.luogu.com.cn/problem/P3373">2.【模板】线段树 2</a></h4><p><a href="https://www.luogu.com.cn/paste/aatmfvej">code</a></p><h2 id="线段树结构分析"><a href="#线段树结构分析" class="headerlink" title="线段树结构分析"></a>线段树结构分析</h2><h4 id="1-THUPC2021-初赛-线段树"><a href="#1-THUPC2021-初赛-线段树" class="headerlink" title="1.[THUPC2021 初赛] 线段树"></a><a href="https://www.luogu.com.cn/problem/P7143">1.[THUPC2021 初赛] 线段树</a></h4><blockquote><p>$[1,n]$ 上的广义线段树内 $[l,r]$ 的最小拆分大小为 $2(r-l+1)-|S|$，其中 $S$ 为包含于 $[l,r]$ 的线段树节点。</p></blockquote><p><strong>证明</strong></p><p>将包含于 $[l,r]$ 的线段树节点取出，形成满二叉树森林，根节点的个数为最小拆分大小。<br>叶子节点的个数为 $r-l+1$，那么 $|S|=2(r-l+1)-根节点的个数$。</p><h4 id="2-ZJOI2017-线段树"><a href="#2-ZJOI2017-线段树" class="headerlink" title="2.[ZJOI2017] 线段树"></a><a href="https://www.luogu.com.cn/problem/P5210">2.[ZJOI2017] 线段树</a></h4><blockquote><p>$[l,r]$ 的拆分可以看成 $[l-1,l-1],[r+1,r+1]$ 与二者 lca，的路径的左/右儿子。</p></blockquote><p>不想写了。。。</p><h4 id="3-ZJOI2019-线段树"><a href="#3-ZJOI2019-线段树" class="headerlink" title="3.[ZJOI2019] 线段树"></a><a href="https://www.luogu.com.cn/problem/P5280">3.[ZJOI2019] 线段树</a></h4><p>对点分类。。。</p><h4 id="4-ZJOI2020-传统艺能"><a href="#4-ZJOI2020-传统艺能" class="headerlink" title="4.[ZJOI2020] 传统艺能"></a><a href="https://www.luogu.com.cn/problem/P6630">4.[ZJOI2020] 传统艺能</a></h4><h2 id="扫描线"><a href="#扫描线" class="headerlink" title="扫描线"></a>扫描线</h2><p>这是一种思想。狭义上更偏向于计算几何。</p><h4 id="1-【模板】扫描线"><a href="#1-【模板】扫描线" class="headerlink" title="1.【模板】扫描线"></a><a href="https://www.luogu.com.cn/problem/P5490">1.【模板】扫描线</a></h4><p><a href="https://www.luogu.com.cn/paste/ckicgynk">code</a> 这里也可以维护区间最小值及其个数。</p><h4 id="2-IOI1998-USACO5-5-矩形周长Picture"><a href="#2-IOI1998-USACO5-5-矩形周长Picture" class="headerlink" title="2.[IOI1998] [USACO5.5] 矩形周长Picture"></a><a href="https://www.luogu.com.cn/problem/P1856">2.[IOI1998] [USACO5.5] 矩形周长Picture</a></h4><p><a href="https://www.luogu.com.cn/paste/572dp688">code</a></p><h4 id="3-SDOI2009-HH的项链"><a href="#3-SDOI2009-HH的项链" class="headerlink" title="3.[SDOI2009] HH的项链"></a><a href="https://www.luogu.com.cn/problem/P1972">3.[SDOI2009] HH的项链</a></h4><p>区间 $[l,r]$ 转化为点 $(l,r)$，发现只需求每个点被覆盖个数，扫描线+树状数组实现。</p><p>事实上单纯从左到右扫描，用线段树动态维护信息就是扫描线思想了。这题也可以这样理解。</p><h2 id="可持久化线段树"><a href="#可持久化线段树" class="headerlink" title="可持久化线段树"></a>可持久化线段树</h2><h4 id="1-【模板】可持久化线段树-2"><a href="#1-【模板】可持久化线段树-2" class="headerlink" title="1.【模板】可持久化线段树 2"></a><a href="https://www.luogu.com.cn/problem/P3834">1.【模板】可持久化线段树 2</a></h4><p>对下标扫描线，构建可持久化权值线段树。</p><h4 id="2-Rmq-Problem-mex"><a href="#2-Rmq-Problem-mex" class="headerlink" title="2.Rmq Problem / mex"></a><a href="https://www.luogu.com.cn/problem/P4137">2.Rmq Problem / mex</a></h4><p>权值线段树维护每个值最后出现的位置。离线扫描线或可持久化线段树均可。</p><h4 id="3-CQOI2015-任务查询系统"><a href="#3-CQOI2015-任务查询系统" class="headerlink" title="3.[CQOI2015] 任务查询系统"></a><a href="https://www.luogu.com.cn/problem/P3168">3.[CQOI2015] 任务查询系统</a></h4><p>对时间扫描线，用权值线段树维护优先级，由于强制在线，用可持久化线段树即可。</p><h4 id="4-Destiny"><a href="#4-Destiny" class="headerlink" title="4.Destiny"></a><a href="https://www.luogu.com.cn/problem/CF840D">4.Destiny</a></h4><p>类似绝对众数为排序后第 $\left \lceil \frac{n}{2} \right \rceil$ 个元素。</p><p>记 $d=\left \lceil \frac{r-l+1}{k} \right \rceil$，查询区间第 $d,2d,…$ 大，判断次数是否符合即可。</p><p>可持久化线段树维护，时间复杂度 $O(kn\log n)$。</p><h2 id="线段树合并"><a href="#线段树合并" class="headerlink" title="线段树合并"></a>线段树合并</h2><p>需要考虑的是两个叶子节点的合并和如何只取一个节点。</p><h3 id="树上问题"><a href="#树上问题" class="headerlink" title="树上问题"></a>树上问题</h3><h4 id="1-雨天的尾巴"><a href="#1-雨天的尾巴" class="headerlink" title="1.雨天的尾巴"></a><a href="https://www.luogu.com.cn/problem/P4556">1.雨天的尾巴</a></h4><p><a href="https://www.luogu.com.cn/paste/3y9u0025">code</a></p><h4 id="2-NOIP2016-提高组-天天爱跑步"><a href="#2-NOIP2016-提高组-天天爱跑步" class="headerlink" title="2.[NOIP2016 提高组] 天天爱跑步"></a><a href="https://www.luogu.com.cn/problem/P1600">2.[NOIP2016 提高组] 天天爱跑步</a></h4><p>可以把玩家拆成向上和向下的两条链，两条链时间均递减/增，与深度联系一下就能转化为雨天的尾巴。</p><h3 id="整体-DP"><a href="#整体-DP" class="headerlink" title="整体 DP"></a>整体 DP</h3><p>对于树上 DP 问题，可用线段树维护其中一维，加入子节点时用线段树合并转移，可以优化时间和空间。</p><h4 id="1-PKUWC2018-Minimax"><a href="#1-PKUWC2018-Minimax" class="headerlink" title="1.[PKUWC2018] Minimax"></a><a href="https://www.luogu.com.cn/problem/P5298">1.[PKUWC2018] Minimax</a></h4><p>所有叶子节点都有概率被取到，先离散化一下，计算出根节点取第 $i$ 小权值的概率即可计算答案。</p><p>记 $f[u][i]$ 为 $u$ 节点取 $i$ 号权值（即为第 $i$ 小）的概率。由于子节点数小于 $2$ ，可以分讨一下</p><ul><li>若 $u$ 为叶子节点，直接更新。</li><li>若 $u$ 只有一个子节点，直接取子节点的值。</li><li>若 $u$ 有两个子节点。<script type="math/tex; mode=display">  f[u][i]=f[lc][i](p[u]\sum_{j=1}^{i-1} f[rc][j]+(1-p[u])\sum_{j=i+1}^{m} f[rc][j])+f[rc][i](p[u]\sum_{j=1}^{i-1} f[lc][j]+(1-p[u])\sum_{j=i+1}^{m} f[lc][j])</script></li></ul><p>可以前缀和后缀和优化 $O(n^2)$ 暴力计算。</p><p>考虑权值线段树维护第二维区间和（其实就是概率和）。需要合并两个子节点的值，考虑其中一个节点为空的情况，发现另一个节点的所有值都需要乘同一个值，写一个区间乘即可。具体实现时，一边合并，一边记录前缀后缀和。</p><h4 id="2-NOI2020-命运"><a href="#2-NOI2020-命运" class="headerlink" title="2.[NOI2020] 命运"></a><a href="https://www.luogu.com.cn/problem/P6773">2.[NOI2020] 命运</a></h4><p>考虑树上 DP。在枚举 $u$ 点时，需要管的链肯定是下端点在子树中且未被满足的，此时应考虑 $u$ 到子节点的边的取值。</p><p>不难发现只需要考虑上端点在 $u$ 上方且深度最大的链，如果它被满足，则其他所有链都被满足（在 $u$ 上方这个限制不用特意注意）。</p><p>可以记 $f(u,i)$ 为下端点在 $u$ 的子树内且未被满足的链的上端点的最大深度为 $i$ 的方案数。每次加一个子节点转移</p><script type="math/tex; mode=display">f(u,i)'=f(u,i)(sum(v,dep_u)+sum(v,i))+sum(u,i-1)f(v,i)</script><p>与前缀和有关，且开始有值的点很少，用线段树合并优化。具体实现时在 <code>merge</code> 中记录两棵线段树的前缀和可以减少查询的 $\log$。对于 $sum(u,i-1)$ 在有个节点为空时不需要管，因为空节点值为 $0$。当 $l=r$ 时，需要考虑，应该后更新该节点的前缀和。时间复杂度 $O(n\log n)$。</p><h2 id="线段树分裂"><a href="#线段树分裂" class="headerlink" title="线段树分裂"></a>线段树分裂</h2><h4 id="1-【模板】线段树分裂"><a href="#1-【模板】线段树分裂" class="headerlink" title="1.【模板】线段树分裂"></a><a href="https://www.luogu.com.cn/problem/P5494">1.【模板】线段树分裂</a></h4><p><a href="https://www.luogu.com.cn/paste/iuk6h36n">code</a> 还可以平衡树合并。</p><h2 id="树套树"><a href="#树套树" class="headerlink" title="树套树"></a>树套树</h2><p><a href="/notes/树套树">详见</a></p><h2 id="李超线段树"><a href="#李超线段树" class="headerlink" title="李超线段树"></a>李超线段树</h2><p>支持插入线段，查询某位置交点最值。</p><h4 id="1-【模板】李超线段树-HEOI2013-Segment"><a href="#1-【模板】李超线段树-HEOI2013-Segment" class="headerlink" title="1.【模板】李超线段树 / [HEOI2013] Segment"></a><a href="https://www.luogu.com.cn/problem/P4097">1.【模板】李超线段树 / [HEOI2013] Segment</a></h4><p><a href="https://www.luogu.com.cn/paste/q18lbhyl">code</a></p><h4 id="2-丝之割"><a href="#2-丝之割" class="headerlink" title="2.丝之割"></a><a href="https://www.luogu.com.cn/problem/P6047">2.丝之割</a></h4><p>为了方便，先将第一行反转一下，并将线的位置加 $1$。一些被包含的线是没用的将其去掉。剩下的按第一行的位置排序，第二行的位置是单减的。</p><p>考虑 DP，记 $f(i)$ 为处理到第 $i$ 个的最小花费。转移显然可以斜率优化。用李超线段树即可，时间复杂度 $O(n\log n)$（是单 $\log$ 因为是插入直线）。</p><h4 id="3-Escape-Through-Leaf"><a href="#3-Escape-Through-Leaf" class="headerlink" title="3.Escape Through Leaf"></a><a href="https://www.luogu.com.cn/problem/CF932F">3.Escape Through Leaf</a></h4><p>暴力树上 DP 显然，用李超线段树合并维护。线段树合并的时间复杂度是 $O(n\log n)$ 的，第一篇题解有势能分析。</p><p>dsu on tree 可以做到 $O(n\log^2n)$。</p><h4 id="4-Sum-of-Prefix-Sums"><a href="#4-Sum-of-Prefix-Sums" class="headerlink" title="4.Sum of Prefix Sums"></a><a href="https://www.luogu.com.cn/problem/CF1303G">4.Sum of Prefix Sums</a></h4><p>有点类似直径，但是很复杂，不能 DP 或贪心。考虑点分治，合并路径时用李超线段树。时间复杂度 $O(n\log^2n)$。</p><h2 id="线段树维护矩阵"><a href="#线段树维护矩阵" class="headerlink" title="线段树维护矩阵"></a>线段树维护矩阵</h2><h3 id="序列问题"><a href="#序列问题" class="headerlink" title="序列问题"></a>序列问题</h3><h4 id="1-Bear-and-Cavalry"><a href="#1-Bear-and-Cavalry" class="headerlink" title="1.Bear and Cavalry"></a><a href="https://www.luogu.com.cn/problem/CF573D">1.Bear and Cavalry</a></h4><h3 id="树上问题-1"><a href="#树上问题-1" class="headerlink" title="树上问题"></a>树上问题</h3><h4 id="1-【模板】”动态-DP”-amp-动态树分治"><a href="#1-【模板】”动态-DP”-amp-动态树分治" class="headerlink" title="1.【模板】”动态 DP”&amp;动态树分治"></a><a href="https://www.luogu.com.cn/problem/P4719">1.【模板】”动态 DP”&amp;动态树分治</a></h4><p>如果没有修改，我们可以简单用 DP 求解。记 $dp(u,0/1)$ 为 $u$ 的子树，$u$ 选或不选的最大独立集，有</p><script type="math/tex; mode=display">dp(u,0)=\sum_{v}\max(dp(v,0),dp(v,1)) \\dp(u,1)=\sum_{v}dp(v,0)+a_u</script><p>对于每个点选出一个特殊的子节点 $x$，记 $f_u=\sum_{v \ne x} \max(dp(v,0),dp(v,1))$，$g_u=\sum_{v \ne x}dp(v,0)+a[u]$。那么有</p><script type="math/tex; mode=display">dp(u,0)=\max(dp(x,0),dp(x,1))+f_u \\dp(u,1)=dp(x,0)+g_u</script><p>写成 $(\max,+)$ 广义矩阵乘法的形式就是</p><script type="math/tex; mode=display">\begin{bmatrix}  dp[u][0] \\  dp[u][1]\end{bmatrix}=\begin{bmatrix}  f[u] & f[u] \\  g[u] & -\infty\end{bmatrix}\begin{bmatrix}  dp[x][0] \\  dp[x][1]\end{bmatrix}</script><p>令 $x$ 为 $u$ 的重儿子，用线段树维护矩阵乘法，那么修改一个点，只会对 $O(\log n)$ 条重链造成影响。</p><p><a href="https://www.luogu.com.cn/paste/jvns0zm5">code</a></p><h4 id="2-ZJOI2019-Minimax搜索"><a href="#2-ZJOI2019-Minimax搜索" class="headerlink" title="2.[ZJOI2019] Minimax搜索"></a><a href="https://www.luogu.com.cn/problem/P5281">2.[ZJOI2019] Minimax搜索</a></h4><p>限制是取 $\max$ 的形式，考虑求出 $\max \le k$ 的方案数再差分。<br>考虑如何对单个 $k$ 快速求出答案。</p><p>记 $dp_u$ 为没有变化时 $u$ 点的值。那么 $1 \to dp_1$ 形成了一条 $dp$ 值都为 $dp_1$ 的链，只要链上任意节点的 $dp$ 值改变，答案一定改变。</p><p>对于叶子节点 $u$，若 $dep_{lca(u,dp_1)}$ 为奇数，那么若改变 $u$，则 $dp_u$ 变为 $dp_u + k$，偶数同理。</p><p>记 $f_u$ 为可以使 $dp_u \le dp_1$ 的方案数（叶子节点需要特判）$cnt_u$ 为 $u$ 子树中总方案数。答案为</p><script type="math/tex; mode=display">cnt_1 - \prod_{dp_u = dp_1} ([dep_u\%2=1]f_u + [dep_u\%2=0](cnt_u-f_u))</script><p>$f$ 也是好计算的，就可以 $O(n)$ 求出特定 $k$ 的答案了。随着 $k$ 的变化，变化的 DP 值为某几个叶子节点，考虑动态 DP。记</p><script type="math/tex; mode=display">g_u = \begin{cases} cnt_u - f_u & \text{ if } dep_u\%2=1\\ f_u & \text{ if } dep_u\%2=0  \end{cases}</script><p>这样转移式子优化为一个形式，动态 DP，时间复杂度 $O(n\log^2n)$。</p><h2 id="线段树维护树上信息"><a href="#线段树维护树上信息" class="headerlink" title="线段树维护树上信息"></a>线段树维护树上信息</h2><h3 id="维护直径"><a href="#维护直径" class="headerlink" title="维护直径"></a>维护直径</h3><h4 id="1-CEOI2019-Dynamic-Diameter"><a href="#1-CEOI2019-Dynamic-Diameter" class="headerlink" title="1.[CEOI2019] Dynamic Diameter"></a><a href="https://www.luogu.com.cn/problem/P6845">1.[CEOI2019] Dynamic Diameter</a></h4><p><strong>贪心</strong></p><p>并集的直径端点一定在原四个端点中，线段树维护即可。时间复杂度 $O(n\log^2n)$，$O(1)$ 求 lca 可以优化到 $O(n\log n)$。</p><p>注意：贪心只有在边权非负的情况下才是对的。</p><p><a href="https://www.luogu.com.cn/paste/i1ypk48w">code</a></p><p><strong>dfs 序</strong></p><p>一个节点无论访问还是回溯都记录下来，这样会得到一个长为 $2n-1$ 序列（ $rt$ 出现次数为$deg[rt]+1$ ，其他点出现的次数为 $deg[u]$ ），即为树的 dfs 序。</p><p>它有一个很好的性质：将原节点记为第一次出现的位置，则 $\min_{i=u}^{v} dep[i] = dep[lca(u,v)]$ ，考虑 dfs 过程不难理解。那么 $dis(u,v)=dep[u]+dep[v]-2\min_{i=u}^{v} dep[i]$。</p><p>用线段树维护直径 $s$，$\min_{u}dep[u]$，$\max_{u}dep[u]$，$\max_{u}\{dep[u]-2\min_{i=l}^{u}dep[i]\}$，$\max_{u}\{dep[u]-2\min_{i=u}^{r}dep[i]\}$。</p><p>注意：该方法仅适用于边权非负，这样才能保证区间中 dep 最小的点为 lca。</p><p><a href="https://www.luogu.com.cn/paste/nzwod7r0">code</a></p><h4 id="2-Tree-Generator™"><a href="#2-Tree-Generator™" class="headerlink" title="2.Tree Generator™"></a><a href="https://www.luogu.com.cn/problem/CF1149C">2.Tree Generator™</a></h4><p><strong>括号序列</strong></p><p>构造一棵树的括号序列：dfs，向下就加‘（’，向上就加‘）’  。长度为 $2*n-2$ ，因为每条边会被访问两次</p><ul><li><p><strong>性质一：</strong> 一段括号序列去掉对应的括号对应树的一条链（思考 dfs 过程）。</p></li><li><p><strong>性质二：</strong> 一段括号序列去掉对应的括号所得序列的长度记为树上链的长度。</p></li></ul><p>去掉对应括号的序列只有三种</p><ul><li><p>))))))…</p></li><li><p>((((((…</p></li><li><p>)))…(((</p></li></ul><p>考虑一般化，将‘（’视为 1， ‘）’视为 -1 ，则该链的长度为 $\max_{i=l-1}^{r}\{v(i+1,r)-v(l,i)\}$。直径即为最大的链长，类似最大子段和，用线段树维护。</p><p><a href="https://www.luogu.com.cn/paste/69grhz2s">code</a></p><h3 id="维护最小连通子树"><a href="#维护最小连通子树" class="headerlink" title="维护最小连通子树"></a>维护最小连通子树</h3><p>给定 $n$ 个关键点，动态维护 $n$ 个关键点所形成的最小连通子树大小。</p><p>将n个点按dfn序从小到大排序为 $0,2,…,n-1$ ，则子树大小为 $\frac{1}{2}\sum_{i=0}^{n-1}dis(i,(i+1)\%n)$。</p><h4 id="1-SDOI2015-寻宝游戏"><a href="#1-SDOI2015-寻宝游戏" class="headerlink" title="1.[SDOI2015] 寻宝游戏"></a><a href="https://www.luogu.com.cn/problem/P3320">1.[SDOI2015] 寻宝游戏</a></h4><p><strong>线段树</strong></p><p>一般用于关键点</p><script type="math/tex; mode=display">\frac{1}{2}\sum_{i=0}^{n-1}dis(i,(i+1)\%n)</script><script type="math/tex; mode=display">=\sum_{i=0}^{n-1}dep[i]-\sum_{i=0}^{n-1}dep[lca(i,(i+1)\%n)]</script><p>考虑如何合并，拆一下 $\%$</p><script type="math/tex; mode=display">\sum_{i=l}^{r}dep[i]-\sum_{i=l}^{r-1}dep[lca(i,(i+1)]-dep[lca(l,r)]</script><script type="math/tex; mode=display">\sum_{i=l}^{mid}dep[i]+\sum_{i=mid+1}^{r}dep[i]-\sum_{i=l}^{mid-1}dep[lca(i,i+1)]-dep[lca(mid,mid+1)]-\sum_{i=mid+1}^{r-1}dep[lca(i,i+1)]-dep[lca(l,r)]</script><script type="math/tex; mode=display">=ans[lc]+ans[rc]+dep[lca(l,mid-1)]+dep[lca(mid+1,r)]-dep[lca(l,r)]-dep[lca(mid,mid+1)]</script><p>有点麻烦，考虑不维护 $dep[lca(l,r)]$</p><script type="math/tex; mode=display">\sum_{i=l}^{r}dep[i]-\sum_{i=l}^{r-1}dep[lca(i,i+1)]</script><script type="math/tex; mode=display">=ans[lc]+ans[rc]-dep[lca(mid,mid+1)]</script><p>简单多了，最后减去即可。时间复杂度 $O(n\log^2n)$ ， $O(1)$ 求 lca 可做到 $O(n\log n)$。</p><p><a href="https://www.luogu.com.cn/paste/dd8wtgon">code</a></p><p><strong>set</strong></p><p>非常简单的做法，直接维护最开始的式子，记 $ans$ 为最终答案。</p><p>每次加入 $u$ ，则 $ans+=dis(pre(u),u)+dis(u,nxt(u))-dis(pre(u),nxt(u))$。</p><p>每次减去 $u$ ，则 $ans+=dis(pre(u),,nxt(u))-dis(pre(u),u)-dis(u,nxt(u))$。</p><p>需要加入删除一个数，求前驱后继，用平衡树维护即可（可以用 set）。</p><p><a href="https://www.luogu.com.cn/paste/rdtcb4fq">code</a></p><h4 id="2-ZJOI2019-语言"><a href="#2-ZJOI2019-语言" class="headerlink" title="2.[ZJOI2019] 语言"></a><a href="https://www.luogu.com.cn/problem/P5327">2.[ZJOI2019] 语言</a></h4><p>对于两元关系的统计，先固定一点 $u$，考虑如何求出 $(u,x)/(x,u)$ 的数量。</p><p>将所有经过 $u$ 的路径赋值为 1 ，统计 1 的个数，除以二即为答案。</p><p>树上的若干条链，经过同一个点，那么就形成了一个连通子树。</p><p>对于每个节点，我们都可以用线段树来维护最小连通子树。</p><p>差分，然后线段树合并即可，时间复杂度 $O(n\log^2n)$ ，同上可以优化为 $O(n\log n)$。</p><p><a href="https://www.luogu.com.cn/paste/9w7w1rv6">code</a></p><h2 id="线段树优化建图"><a href="#线段树优化建图" class="headerlink" title="线段树优化建图"></a>线段树优化建图</h2><p>一般优化三种连边</p><ul><li><p>$x \to [l,r]$</p></li><li><p>$[l,r] \to x$</p></li><li><p>$[l,r] \to [l’,r’]$</p></li></ul><p>主要思想是建虚点代表一个区间。</p><h4 id="1-Legacy"><a href="#1-Legacy" class="headerlink" title="1.Legacy"></a><a href="https://www.luogu.com.cn/problem/CF786B">1.Legacy</a></h4><p>建一棵根向线段树，一棵叶向线段树。</p><p>我的 dij 板子怎么是错的？？？</p><p><a href="https://codeforces.com/contest/786/submission/296784211">code</a></p><h4 id="2-「JOISC-2020-Day4」治疗计划"><a href="#2-「JOISC-2020-Day4」治疗计划" class="headerlink" title="2.「JOISC 2020 Day4」治疗计划"></a><a href="https://loj.ac/p/3282">2.「JOISC 2020 Day4」治疗计划</a></h4><p>$O(m^2)$ 是简单的。考虑优化，套路地想数据结构优化。拆一下绝对值，如果 $i \to j$，那么</p><ul><li><p>$t_j&lt;t_i: r_i-t_i+1 \ge l_j-t_j$.</p></li><li><p>$t_j&gt;t_i: r_i+t_i+1 \ge l_j+t_j$.</p></li></ul><p>由于连向某个点的权值都相同，所以每个点在被枚举到时其 $dis$ 就已经确定。考虑快速找出邻点，这样均摊是对的。先按 $t$ 排序，然后线段树，时间复杂度 $O(n\log n)$。</p><h2 id="单侧递归线段树"><a href="#单侧递归线段树" class="headerlink" title="单侧递归线段树"></a>单侧递归线段树</h2><p><a href="/notes/单侧递归线段树">详见</a></p><h2 id="线段树分治"><a href="#线段树分治" class="headerlink" title="线段树分治"></a>线段树分治</h2><p>不如叫基于时间的分治。</p><h4 id="1-二分图-【模板】线段树分治"><a href="#1-二分图-【模板】线段树分治" class="headerlink" title="1.二分图 /【模板】线段树分治"></a><a href="https://www.luogu.com.cn/problem/P5787">1.二分图 /【模板】线段树分治</a></h4><h4 id="2-Painting-Edges"><a href="#2-Painting-Edges" class="headerlink" title="2.Painting Edges"></a><a href="https://www.luogu.com.cn/problem/CF576E">2.Painting Edges</a></h4><p>一棵树，每条边有颜色（开始没有），当加入任意一种颜色的边时，图都为二分图，则此时合法。每次操作改变某条边的颜色，只有当改变后合法才会进行，判断每次操作是否会进行。</p><p>颜色很少，考虑对每个颜色开一个并查集维护。</p><p>我们并不能将操作离线下来，但每个时间只有一次操作，可以按时间先后线段树分治，先将操作挂在对应的叶子节点上，递归到该点时判断是否合法，并将对应区间进行覆盖（原颜色或更改的颜色）。</p><p>由于每次操作后图一定合法（不然不会操作），所以在叶子节点只需判断加入挂着的边后是否合法即可。</p><p>时间复杂度 $O(m\log q\log n+nk)$。</p><p>注意：不要手写栈，因为实际加入堆的元素个数为 $2(拆后的总边数)$ 而手写栈要开到 $2k(拆后的总边数)$ 空间会炸。</p><p><a href="https://www.luogu.com.cn/paste/ky04ivij">code &amp; data_maker</a></p><h2 id="线段树维护历史值-amp-segment-tree-beats"><a href="#线段树维护历史值-amp-segment-tree-beats" class="headerlink" title="线段树维护历史值 &amp; segment tree beats"></a>线段树维护历史值 &amp; segment tree beats</h2><p><a href="/notes/seg_beats">详见</a></p><h2 id="KTT"><a href="#KTT" class="headerlink" title="KTT"></a>KTT</h2><p><a href="notes/KTT">详见</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.luogu.com/article/xjsrcztd">线段树相关技巧的小小总结（修订版）</a></p><p><a href="https://www.cnblogs.com/alex-wei/p/18356369/SegmentTreePart1">线段树进阶 Part 1</a></p>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>hash</title>
      <link href="/notes/hash/"/>
      <url>/notes/hash/</url>
      
        <content type="html"><![CDATA[<p>有两种方式，个人习惯用 $h(n) = \sum_{i=1}^{n} s_i \times base^i$。常用 $base = 139,MOD = 1011451423$。</p><p>有 $h(l,r) = (h(r) - h(l-1)) \times base^{n-r}$。</p><p>对于反串，有 $h(n) = \sum_{i=1}^{n} s_i \times base^{n-i+1},h(l,r) = (h(r) - h(l)) \times base^{l-1}$。</p><p>可以用树状数组或线段树动态维护。</p>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>KMP</title>
      <link href="/notes/KMP/"/>
      <url>/notes/KMP/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>对于统计 $S$ 在 $T$ 中的出现次数的问题。称 $S$ 为模板串，$T$ 为文本串。KMP 算法可以解决单模板串匹配问题。</p><p>先对模板串预处理 nxt 数组，代表 $[1,i]$ 的最长相等真前后缀的长度。也可以理解为在模板串上建立自动机。</p><p>然后遍历文本串进行匹配，时间复杂度均摊为 $O(n+m)$。</p><p><a href="https://www.luogu.com.cn/problem/P3375">【模板】KMP</a> <a href="https://www.luogu.com.cn/record/190450329">code</a></p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h4 id="最短循环节"><a href="#最短循环节" class="headerlink" title="最短循环节"></a>最短循环节</h4><p>最短循环节存在当且仅当 $(n-nxt_n) | n$，此时最短循环节长度为 $n-nxt_n$。</p><h4 id="1-Prefix-Function-Queries"><a href="#1-Prefix-Function-Queries" class="headerlink" title="1.Prefix Function Queries"></a><a href="https://www.luogu.com.cn/problem/CF1721E">1.Prefix Function Queries</a></h4><p>可以每次加入 $\text{t}$ 后从 $\text{t}$ 开始跑 KMP，但这样时间复杂度不对（因为时间复杂度是均摊的）。</p><p>可以对于 $\text{s}$ 预处理出从 $i$ 开始，与 $\text{c}$ 匹配跳 fail 最终跳到的节点，这样当 $p \le n$ 时就可以 $O(1)$ 转移了。</p><p>时间复杂度 $O(SZ|\text{s}| + \sum |\text{t}|)$。</p><p>用可持久化线段树可以优化至 $O(|\text{s}| \log SZ)$</p><h4 id="2-CERC2019-ABB"><a href="#2-CERC2019-ABB" class="headerlink" title="2.[CERC2019] ABB"></a><a href="https://www.luogu.com.cn/problem/P9606">2.[CERC2019] ABB</a></h4><p>一个串最少加入 $n-最长回文后缀$ 个字符形成一个回文串。</p><p>求最长回文后缀可以求 $\overline{s} + “!” + s$ 的 $border$</p><h4 id="3-POI2005-SZA-Template"><a href="#3-POI2005-SZA-Template" class="headerlink" title="3.[POI2005] SZA-Template"></a><a href="https://www.luogu.com.cn/problem/P3426">3.[POI2005] SZA-Template</a></h4><p>印章一定是原串的一段前缀。</p><p>考虑 DP，记 $f_i$ 为 $[1,i]$ 需要的最短长度。</p><p>发现 $f_i$ 只有 $i$ 和 $f_{nxt_i}$ 两种取值。最起码要能覆盖 $[1,nxt_i]$，再多了就不能覆盖 $[i-nxt_i+1,i]$ 了。</p><p>只有当 $[i-nxt_i,i]$ 中存在 $j$ 使得 $f_j = f_{nxt_i}$ 时，$f_i$ 才取 $f_{nxt_i}$。用个桶记录最大位置。</p><h4 id="4-【模板】失配树"><a href="#4-【模板】失配树" class="headerlink" title="4.【模板】失配树"></a><a href="https://www.luogu.com.cn/problem/P5829">4.【模板】失配树</a></h4><p>建出 $\text{fail}$ 树，找两个点父节点的 $\text{LCA}$。</p><h4 id="5-NOI2014-动物园"><a href="#5-NOI2014-动物园" class="headerlink" title="5.[NOI2014] 动物园"></a><a href="https://www.luogu.com.cn/problem/P2375">5.[NOI2014] 动物园</a></h4><p>建出失配树，维护 $f_{u}$ 表示 $u$ 的答案，每次对子节点取 $\min$ 再往上跳即可。最后答案为深度。</p><p>也可以维护一个栈，中间维护一个指针，个数即为指针的位置。</p>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Burnside</title>
      <link href="/notes/Burnside/"/>
      <url>/notes/Burnside/</url>
      
        <content type="html"><![CDATA[<p>只是一些定义，具体例子去看组合数学。</p><h2 id="置换"><a href="#置换" class="headerlink" title="置换"></a>置换</h2><p>对于排列 $X$，将函数 $f:X \to X$ 称为置换。也可以记作</p><script type="math/tex; mode=display">\begin{pmatrix}1 & 2 & ... & n \\i_1 & i_2 & ... & i_n\end{pmatrix}</script><p>定义置换的合成 $f \circ g$，有 $(f \circ g)(k) = f(g(k))$。</p><p>定义置换群 $G$ 满足</p><ul><li><p>$\forall f,g \in G, f \circ g \in G$。</p></li><li><p>存在单位元。</p></li><li><p>$\forall f \in G, f^{-1} \in G$。</p></li></ul><h2 id="着色"><a href="#着色" class="headerlink" title="着色"></a>着色</h2><p>记 $C$ 为颜色集合，将函数 $c:X \to C$ 称为着色。</p><p>定义颜色的置换 $f*c$ ，有 $(f*c)(i_k)=c(k)$。</p><p>$c_1$ 与 $c_2$ 等价当且仅当 $\exists f \in G, f*c = c$，记作 $c_1 \sim c_2$。</p><p>定义着色集 $\mathcal{C}$ 满足</p><ul><li>$\forall f \in G,c \in \mathcal{C}, f*c \in \mathcal{C}$。</li></ul><h2 id="Burnside-定理"><a href="#Burnside-定理" class="headerlink" title="Burnside 定理"></a>Burnside 定理</h2><p>定义 $G(c) = \{f|f \in G,f*c=c\},\mathcal{C}(f) = \{c|c \in \mathcal{C},f*c=c\}$ 也称为不动点。</p><blockquote><p>与 $c$ 等价的着色个数 = $\frac{|G|}{|G(c)|}$。</p></blockquote><p><strong>证明</strong></p><p>$\forall f \in G,g \in G(c)$ 有 $(f \circ g)*c = f*(g*c) = f*c$。</p><p>而每个 $f \circ g$ 是不同的，因此对 $c$ 作用与 $f$ 相同的置换个数为 $|G(c)|$，总置换个数为 $|G|$，所以与 $c$ 等价的不同的着色有 $\frac{|G|}{|G(c)|}$ 种。</p><blockquote><p>Burnside 定理：$非等价着色数 = \frac{1}{|G|} \sum_{f \in G} |\mathcal{f}|$</p><p>用人话将就是，本质不同的着色个数为所有置换不动点个数的平均值。</p></blockquote><p><strong>证明</strong></p><script type="math/tex; mode=display">\begin{align}\sum_{f \in G} |\mathcal{C}(f)| &= \sum_{c \in \mathcal{c}} |G(c)| \\\sum_{f \in G} |\mathcal{C}(f)| &= \sum_{c \in \mathcal{c}} \frac{|G|}{与 c 等价的着色的个数} \\\sum_{f \in G} |\mathcal{C}(f)| &= |G|(非等价着色数) \\(非等价着色数) &= \frac{1}{|G|} \sum_{f \in G} |\mathcal{C}(f)|\end{align}</script><h2 id="Polya-定理"><a href="#Polya-定理" class="headerlink" title="Polya 定理"></a>Polya 定理</h2><p>浅浅写一下。</p><p>置换可以被几个循环的合并代替。例</p><script type="math/tex; mode=display">\begin{pmatrix}1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 \\4 & 9 & 1 & 7 & 6 & 5 & 3 & 8 & 2\end{pmatrix} = [1 \ 4 \ 7 \ 3] \circ [2 \ 9] \circ [5 \ 6] \circ [8]</script><p>计算着色方案数时，我们只关心大小一定的循环有多少个，因此一个置换群可以被一个生成函数代替。</p><p>该方法的优势在于可以限定颜色的个数。</p><h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><h4 id="1-【模板】Polya-定理"><a href="#1-【模板】Polya-定理" class="headerlink" title="1.【模板】Polya 定理"></a><a href="https://www.luogu.com.cn/problem/P4980">1.【模板】Polya 定理</a></h4><p>有 $n$ 种置换，即旋转 $[1,n]$ 次（这里将 $0$ 归为 $n$ 方便计算）。</p><p>对于旋转 $k$ 次的，其不动点个数为 $n^{\gcd(n,k)}$。所以答案为</p><script type="math/tex; mode=display">\begin{align}\frac{1}{n} \sum_{k=1}^{n} n^{\gcd(n,k)} &= \frac{1}{n} \sum_{d|n} n^d \sum_{k=1}^{n} [\gcd(n,k)=d] \\&= \sum_{d|n} n^d \varphi(\frac{n}{d})\end{align}</script><p>单点求 $\varphi$，时间复杂度 $O(n\sqrt{n}\log n)$（可以通过预处理将 $\log n$ 去掉）。</p><h4 id="2-JSOI2012-爱之项链"><a href="#2-JSOI2012-爱之项链" class="headerlink" title="2.[JSOI2012] 爱之项链"></a><a href="https://www.luogu.com.cn/problem/P5233">2.[JSOI2012] 爱之项链</a></h4><p><del>搬题人的 id 提示了此题的做法。</del></p><p>求一个戒指的方案数同上，记方案数为 $k$。考虑容斥，答案为</p><script type="math/tex; mode=display">\begin{align}\sum_{i=0}^{n-2} (-1)^{i} k(k-1)^{n-1-i} &= (-1)^{n-1} k \sum_{i=1}^{n-1} (1-k)^{i} \\&= (-1)^{n-1} k \frac{(1-k)^{n}-(1-k)}{-k} \\&= (k-1)^{n} + (-1)^{n} (k-1)\end{align}</script><p>$n=1$ 要特判？</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>组合数学（第五版）</p>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
